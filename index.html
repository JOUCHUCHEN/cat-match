const rows = 8;
const cols = 8;
const catTypes = 6;
const size = 64;

let board = [];
let selected = null;
let score = 0;

function randomCat() {
  const img = new Image();
  img.src = `cats/cat${Math.floor(Math.random() * catTypes) + 1}.png`;
  return img;
}

function setup() {
  createCanvas(cols * size, rows * size + 50);
  initBoard();
}

function initBoard() {
  for (let y = 0; y < rows; y++) {
    board[y] = [];
    for (let x = 0; x < cols; x++) {
      let cat = randomCat();
      board[y][x] = { img: cat, x, y, targetY: y * size, falling: false };
    }
  }
  removeMatches();
}

function draw() {
  background(255);
  drawBoard();
  drawScore();
  updateFalling();
}

function drawBoard() {
  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      let cell = board[y][x];
      if (cell && cell.img) {
        image(cell.img, x * size, cell.targetY, size, size);
      }
    }
  }
}

function drawScore() {
  fill(0);
  textSize(24);
  text(`ÂñµÈ≥¥ÂÄºÔºö${score}`, 10, height - 10);
}

function mousePressed() {
  let x = Math.floor(mouseX / size);
  let y = Math.floor(mouseY / size);
  if (x < 0 || x >= cols || y < 0 || y >= rows) return;

  if (!selected) {
    selected = { x, y };
  } else {
    if (dist(selected.x, selected.y, x, y) === 1) {
      swapCats(selected, { x, y });
      if (!removeMatches()) {
        // Ê≤íÊúâÈÖçÂ∞çÊàêÂäü ‚Üí ÊªëÂõûÂéü‰Ωç
        setTimeout(() => swapCats(selected, { x, y }), 200);
      }
    }
    selected = null;
  }
}

function swapCats(a, b) {
  let temp = board[a.y][a.x];
  board[a.y][a.x] = board[b.y][b.x];
  board[b.y][b.x] = temp;
}

function removeMatches() {
  let remove = [];
  // Ê∞¥Âπ≥
  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols - 2; x++) {
      if (board[y][x] && board[y][x + 1] && board[y][x + 2]) {
        if (board[y][x].img.src === board[y][x + 1].img.src &&
            board[y][x].img.src === board[y][x + 2].img.src) {
          remove.push({ x, y }, { x: x + 1, y }, { x: x + 2, y });
        }
      }
    }
  }
  // ÂûÇÁõ¥
  for (let y = 0; y < rows - 2; y++) {
    for (let x = 0; x < cols; x++) {
      if (board[y][x] && board[y + 1][x] && board[y + 2][x]) {
        if (board[y][x].img.src === board[y + 1][x].img.src &&
            board[y][x].img.src === board[y + 2][x].img.src) {
          remove.push({ x, y }, { x, y: y + 1 }, { x, y: y + 2 });
        }
      }
    }
  }

  if (remove.length > 0) {
    score += remove.length;
    remove.forEach(p => board[p.y][p.x] = null);
    setTimeout(dropCats, 200); // ‚¨ÖÔ∏è Á´ãÂç≥ÊªëËêΩ
    return true;
  }
  return false;
}

function dropCats() {
  for (let x = 0; x < cols; x++) {
    let emptySpaces = 0;
    for (let y = rows - 1; y >= 0; y--) {
      if (board[y][x] === null) {
        emptySpaces++;
      } else if (emptySpaces > 0) {
        // ‰∏ãÊªë
        board[y + emptySpaces][x] = board[y][x];
        board[y][x] = null;
        board[y + emptySpaces][x].targetY = (y + emptySpaces) * size;
        board[y + emptySpaces][x].falling = true;
      }
    }
    // Áî¢ÁîüÊñ∞ÂúñÊ°à
    for (let i = 0; i < emptySpaces; i++) {
      let newCat = randomCat();
      board[i][x] = { img: newCat, x, y: i, targetY: i * size, falling: true };
      // üëá ËÆìÊñ∞Ë≤ìÂæûËû¢Âπï‰∏äÊñπÊéâ‰∏ã‰æÜ
      board[i][x].targetY = i * size;
    }
  }
}

function updateFalling() {
  let fallingSpeed = 12;
  let moving = false;
  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      let cell = board[y][x];
      if (cell && cell.falling) {
        if (cell.targetY > y * size) {
          cell.targetY -= fallingSpeed;
          moving = true;
        } else {
          cell.targetY = y * size;
          cell.falling = false;
        }
      }
    }
  }
  if (!moving) {
    removeMatches();
  }
}
