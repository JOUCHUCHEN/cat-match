<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>喵嗚值消消樂（修正版）</title>
<style>
  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
    background: #f8f8f8;
    margin: 0;
    user-select: none;
    touch-action: none;
  }
  #board {
    display: grid;
    grid-template-columns: repeat(8, 65px);
    grid-template-rows: repeat(8, 65px);
    gap: 4px;
  }
  .cell {
    width: 65px;
    height: 65px;
    background-size: cover;
    border-radius: 10px;
    transition: transform 0.5s ease, background-image 0.3s ease;
  }
  #score {
    font-size: 24px;
    font-weight: bold;
    margin-bottom: 10px;
  }
</style>
</head>
<body>

<div id="score">喵嗚值：0</div>
<div id="board"></div>

<script>
const rows = 8, cols = 8;
const icons = [
  "1.png","2.png","3.png","4.png","5.png","6.png","7.png"
];
let board = [];
let score = 0;
let dragging = false;
let startCell = null;
const scoreEl = document.getElementById("score");

function randomIcon(){
  return icons[Math.floor(Math.random()*icons.length)];
}

function initBoard(){
  board = [];
  for(let r=0;r<rows;r++){
    board[r] = [];
    for(let c=0;c<cols;c++){
      let icon;
      do{
        icon = randomIcon();
        board[r][c] = icon;
      }while(checkInitialMatch(r,c));
    }
  }
  renderBoard();
}

function checkInitialMatch(r,c){
  if(c>=2 && board[r][c]===board[r][c-1] && board[r][c]===board[r][c-2]) return true;
  if(r>=2 && board[r][c]===board[r-1][c] && board[r][c]===board[r-2][c]) return true;
  return false;
}

function renderBoard(){
  const boardDiv = document.getElementById("board");
  boardDiv.innerHTML = "";
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const cell = document.createElement("div");
      cell.className = "cell";
      cell.dataset.row = r;
      cell.dataset.col = c;
      if(board[r][c]) cell.style.backgroundImage = `url(${board[r][c]})`;
      else cell.style.backgroundImage = "none";
      addEvent(cell);
      boardDiv.appendChild(cell);
    }
  }
}

function addEvent(cell){
  cell.addEventListener("mousedown",startDrag);
  cell.addEventListener("touchstart",startDrag);
  cell.addEventListener("mouseup",endDrag);
  cell.addEventListener("touchend",endDrag);
}

function startDrag(e){
  e.preventDefault();
  dragging = true;
  startCell = e.target;
}

function endDrag(e){
  if(!dragging) return;
  dragging = false;
  const endCell = document.elementFromPoint(
    e.changedTouches ? e.changedTouches[0].clientX : e.clientX,
    e.changedTouches ? e.changedTouches[0].clientY : e.clientY
  );
  if(!endCell || !endCell.classList.contains("cell")) return;

  const r1 = +startCell.dataset.row;
  const c1 = +startCell.dataset.col;
  const r2 = +endCell.dataset.row;
  const c2 = +endCell.dataset.col;

  if(Math.abs(r1-r2)+Math.abs(c1-c2)===1){
    swapCellsAnimated(r1,c1,r2,c2);
  }
}

/* ✅ 修正版：加入若無配對則滑回的功能 */
function swapCellsAnimated(r1,c1,r2,c2){
  const cell1 = document.querySelector(`.cell[data-row="${r1}"][data-col="${c1}"]`);
  const cell2 = document.querySelector(`.cell[data-row="${r2}"][data-col="${c2}"]`);
  const temp = board[r1][c1];
  board[r1][c1] = board[r2][c2];
  board[r2][c2] = temp;

  const dx = (c2-c1)*69;
  const dy = (r2-r1)*69;

  cell1.style.transition = "transform 0.3s";
  cell2.style.transition = "transform 0.3s";
  cell1.style.transform = `translate(${dx}px,${dy}px)`;
  cell2.style.transform = `translate(${-dx}px,${-dy}px)`;

  setTimeout(()=>{
    const matches = checkMatches();
    if(matches.length>0){
      cell1.style.transition = "";
      cell2.style.transition = "";
      cell1.style.transform = "";
      cell2.style.transform = "";
      renderBoard();
      handleMatches();
    } else {
      // ❌ 無配對 → 滑回原位
      const back1 = cell1.cloneNode(true);
      const back2 = cell2.cloneNode(true);
      cell1.replaceWith(back1);
      cell2.replaceWith(back2);
      addEvent(back1);
      addEvent(back2);
      board[r2][c2] = board[r1][c1];
      board[r1][c1] = temp;
      back1.style.transition = "transform 0.3s";
      back2.style.transition = "transform 0.3s";
      back1.style.transform = "";
      back2.style.transform = "";
      setTimeout(()=>renderBoard(),300);
    }
  },300);
}

function handleMatches(){
  const matches = checkMatches();
  if(matches.length>0){
    clearMatches(matches);
    setTimeout(()=>{
      applyGravity();
    },300);
  }else if(!hasPossibleMove()){
    gameOver();
  }
}

function checkMatches(){
  const matches = [];
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const icon = board[r][c];
      if(!icon) continue;
      if(c<cols-2 && board[r][c+1]===icon && board[r][c+2]===icon){
        let len=3;
        while(c+len<cols && board[r][c+len]===icon) len++;
        for(let k=0;k<len;k++) matches.push([r,c+k]);
      }
      if(r<rows-2 && board[r+1][c]===icon && board[r+2][c]===icon){
        let len=3;
        while(r+len<rows && board[r+len][c]===icon) len++;
        for(let k=0;k<len;k++) matches.push([r+k,c]);
      }
    }
  }
  return matches;
}

function clearMatches(matches){
  const cleared = {};
  matches.forEach(([r,c])=>{
    const key = r+'-'+c;
    if(!cleared[key]) cleared[key] = true;
  });
  const countMap = {};
  for(const key in cleared){
    const [r,c] = key.split('-').map(Number);
    const icon = board[r][c];
    countMap[icon] = (countMap[icon]||0)+1;
  }
  let addScore = 0;
  for(const icon in countMap){
    const n = countMap[icon];
    if(n===3) addScore += 1*3;
    else if(n===4) addScore += 2*4;
    else if(n>=5) addScore += 3*n;
  }
  score += addScore;
  scoreEl.textContent = "喵嗚值：" + score;

  matches.forEach(([r,c])=>{
    board[r][c] = null;
    const cell = document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
    if(cell) cell.style.backgroundImage = "none";
  });
}

/* ✅ 修正版 applyGravity()：讓上方新圖案隨機高度滑落 */
function applyGravity(){
  const clones = [];
  const cellSize = 69;
  const gap = 4;
  const boardEl = document.getElementById("board");
  const rect = boardEl.getBoundingClientRect();

  for(let c=0;c<cols;c++){
    let empty = 0;
    for(let r=rows-1;r>=0;r--){
      if(board[r][c]===null){
        empty++;
      } else if(empty>0){
        board[r+empty][c] = board[r][c];
        board[r][c] = null;
      }
    }
    for(let i=0;i<empty;i++){
      board[i][c] = randomIcon();
      // 隨機滑落
      const targetY = rect.top + i*(cellSize+gap);
      const startY = rect.top - ((Math.random()*3+1)*(cellSize+gap)*empty);
      const x = rect.left + c*(cellSize+gap);
      const clone = document.createElement("div");
      clone.className = "cell";
      clone.style.position = "fixed";
      clone.style.left = x + "px";
      clone.style.top = startY + "px";
      clone.style.width = "65px";
      clone.style.height = "65px";
      clone.style.backgroundImage = `url(${board[i][c]})`;
      clone.style.zIndex = 999;
      clone.style.transition = "transform 0.5s ease";
      const dy = targetY - startY;
      document.body.appendChild(clone);
      requestAnimationFrame(()=>{
        clone.style.transform = `translateY(${dy}px)`;
      });
      clones.push(clone);
    }
  }

  // 原本存在的圖案下滑
  const domCells = document.querySelectorAll('.cell');
  domCells.forEach(el=>{
    const r = +el.dataset.row;
    const c = +el.dataset.col;
    if(!board[r][c]) return;
    let fall = 0;
    for(let k=r+1;k<rows;k++){
      if(board[k][c]===null) fall++;
    }
    if(fall>0){
      el.style.transition = "transform 0.5s ease";
      el.style.transform = `translateY(${fall*(cellSize+gap)}px)`;
    }
  });

  setTimeout(()=>{
    clones.forEach(cl=>cl.remove());
    renderBoard();
    const newMatches = checkMatches();
    if(newMatches.length>0){
      clearMatches(newMatches);
      setTimeout(()=>applyGravity(),300);
    } else if(!hasPossibleMove()){
      gameOver();
    }
  },500);
}

function hasPossibleMove(){
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      if(r<rows-1){
        swapSimple(r,c,r+1,c);
        if(checkMatches().length>0){swapSimple(r,c,r+1,c);return true;}
        swapSimple(r,c,r+1,c);
      }
      if(c<cols-1){
        swapSimple(r,c,r,c+1);
        if(checkMatches().length>0){swapSimple(r,c,r,c+1);return true;}
        swapSimple(r,c,r,c+1);
      }
    }
  }
  return false;
}

function swapSimple(r1,c1,r2,c2){
  [board[r1][c1],board[r2][c2]]=[board[r2][c2],board[r1][c1]];
}

function gameOver(){
  alert("遊戲結束！最終喵嗚值：" + score);
}

initBoard();
</script>

</body>
</html>
