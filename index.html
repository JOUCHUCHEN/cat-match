<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Cat Match Game</title>
<style>
  body {
    background-color: #fff8f0;
    font-family: "Comic Sans MS", sans-serif;
    text-align: center;
    user-select: none;
  }
  #game {
    display: grid;
    grid-template-columns: repeat(6, 60px);
    grid-template-rows: repeat(6, 60px);
    gap: 5px;
    justify-content: center;
    margin-top: 40px;
  }
  .cell {
    width: 60px;
    height: 60px;
    border-radius: 10px;
    background-color: #fff;
    box-shadow: 0 0 4px rgba(0,0,0,0.2);
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: grab;
    touch-action: none;
  }
  .cell img {
    width: 50px;
    height: 50px;
    transition: transform 0.2s;
    pointer-events: none;
  }
  .cell.dragging {
    opacity: 0.6;
  }
  #score {
    font-size: 20px;
    margin-top: 20px;
  }
  #gameOver {
    display: none;
    margin-top: 20px;
    font-size: 24px;
    color: red;
  }
  #restart {
    display: none;
    margin-top: 10px;
    font-size: 18px;
    background: #ffa;
    border: none;
    padding: 8px 16px;
    border-radius: 10px;
    cursor: pointer;
  }
</style>
</head>
<body>
  <h1>ğŸ¾ Cat Match Game ğŸ¾</h1>
  <div id="game"></div>
  <div id="score">åˆ†æ•¸ï¼š0</div>
  <div id="gameOver">ğŸ’€ éŠæˆ²çµæŸï¼</div>
  <button id="restart" onclick="restartGame()">é‡æ–°é–‹å§‹</button>

<script>
const gridSize = 6;
const images = ["1.PNG","2.PNG","3.PNG","4.PNG","5.PNG","6.png"];
let grid = [];
let score = 0;
let dragging = null;
let draggingElement = null;
let gameOver = false;
const game = document.getElementById("game");

function createGrid() {
  grid = [];
  game.innerHTML = "";
  for (let i = 0; i < gridSize * gridSize; i++) {
    const cell = document.createElement("div");
    cell.className = "cell";
    const img = document.createElement("img");
    img.src = images[Math.floor(Math.random() * images.length)];
    cell.appendChild(img);
    cell.dataset.index = i;
    addDragTouchEvents(cell);
    game.appendChild(cell);
    grid.push(cell);
  }
  setTimeout(() => checkAndRemoveMatches(true), 200);
}

function addDragTouchEvents(cell) {
  cell.addEventListener("mousedown", startDrag);
  cell.addEventListener("touchstart", startDrag);
  cell.addEventListener("mouseup", endDrag);
  cell.addEventListener("touchend", endDrag);
  cell.addEventListener("mousemove", moveDrag);
  cell.addEventListener("touchmove", moveDrag);
}

function startDrag(e) {
  if (gameOver) return;
  e.preventDefault();
  dragging = e.currentTarget;
  dragging.classList.add("dragging");

  draggingElement = dragging.querySelector("img").cloneNode();
  draggingElement.style.position = "fixed";
  draggingElement.style.pointerEvents = "none";
  draggingElement.style.zIndex = "1000";
  draggingElement.style.width = "50px";
  draggingElement.style.height = "50px";
  document.body.appendChild(draggingElement);
  moveDrag(e);
}

function moveDrag(e) {
  if (!draggingElement) return;
  let x, y;
  if (e.touches && e.touches[0]) {
    x = e.touches[0].clientX;
    y = e.touches[0].clientY;
  } else {
    x = e.clientX;
    y = e.clientY;
  }
  draggingElement.style.left = x - 25 + "px";
  draggingElement.style.top = y - 25 + "px";
}

function endDrag(e) {
  if (!dragging) return;
  dragging.classList.remove("dragging");
  if (draggingElement) {
    draggingElement.remove();
    draggingElement = null;
  }

  let target = document.elementFromPoint(
    e.changedTouches ? e.changedTouches[0].clientX : e.clientX,
    e.changedTouches ? e.changedTouches[0].clientY : e.clientY
  );

  if (target && target.classList.contains("cell") && target !== dragging) {
    const cellA = dragging;
    const cellB = target;
    const imgA = cellA.querySelector("img").src;
    const imgB = cellB.querySelector("img").src;

    // æš«æ™‚äº¤æ›
    swapCells(cellA, cellB);

    // æª¢æŸ¥æ˜¯å¦èƒ½æ¶ˆé™¤
    if (!checkAndRemoveMatches()) {
      // ä¸èƒ½æ¶ˆ â†’ æ›å›
      setTimeout(() => {
        cellA.querySelector("img").src = imgA;
        cellB.querySelector("img").src = imgB;
      }, 200);
    }
  }
  dragging = null;
}

function swapCells(cellA, cellB) {
  const imgA = cellA.querySelector("img").src;
  const imgB = cellB.querySelector("img").src;
  cellA.querySelector("img").src = imgB;
  cellB.querySelector("img").src = imgA;
}

function checkAndRemoveMatches(initial = false) {
  let matched = [];
  // æ©«å‘æª¢æŸ¥
  for (let r = 0; r < gridSize; r++) {
    let row = [];
    for (let c = 0; c < gridSize; c++) {
      row.push(r * gridSize + c);
    }
    matched.push(...findMatches(row));
  }
  // ç›´å‘æª¢æŸ¥
  for (let c = 0; c < gridSize; c++) {
    let col = [];
    for (let r = 0; r < gridSize; r++) {
      col.push(r * gridSize + c);
    }
    matched.push(...findMatches(col));
  }

  matched = [...new Set(matched)];
  if (matched.length === 0) {
    if (!initial && !hasPossibleMove()) endGame();
    return false;
  }

  score += matched.length; // âœ… æ ¹æ“šå¯¦éš›æ¶ˆæ‰æ ¼æ•¸åŠ åˆ†
  document.getElementById("score").textContent = "åˆ†æ•¸ï¼š" + score;

  matched.forEach(i => {
    const img = grid[i].querySelector("img");
    img.style.transform = "scale(0)";
    setTimeout(() => {
      img.src = images[Math.floor(Math.random() * images.length)];
      img.style.transform = "scale(1)";
    }, 300);
  });

  setTimeout(checkAndRemoveMatches, 400);
  return true;
}

// å°‹æ‰¾ç›¸åŒåœ–æ¡ˆä¸²ï¼ˆ>=3ï¼‰
function findMatches(indices) {
  let result = [];
  let count = 1;
  for (let i = 1; i < indices.length; i++) {
    const prev = grid[indices[i - 1]].querySelector("img").src;
    const curr = grid[indices[i]].querySelector("img").src;
    if (prev === curr) count++;
    else {
      if (count >= 3) result.push(...indices.slice(i - count, i));
      count = 1;
    }
  }
  if (count >= 3) result.push(...indices.slice(indices.length - count));
  return result;
}

// æ˜¯å¦é‚„æœ‰å¯èƒ½ç§»å‹•
function hasPossibleMove() {
  for (let i = 0; i < grid.length; i++) {
    const right = i + 1;
    const down = i + gridSize;
    if (right < grid.length && Math.floor(right / gridSize) === Math.floor(i / gridSize)) {
      swapCells(grid[i], grid[right]);
      if (detectMatch()) { swapCells(grid[i], grid[right]); return true; }
      swapCells(grid[i], grid[right]);
    }
    if (down < grid.length) {
      swapCells(grid[i], grid[down]);
      if (detectMatch()) { swapCells(grid[i], grid[down]); return true; }
      swapCells(grid[i], grid[down]);
    }
  }
  return false;
}

// æª¢æŸ¥æ˜¯å¦å­˜åœ¨ä¸‰é€£
function detectMatch() {
  for (let r = 0; r < gridSize; r++) {
    for (let c = 0; c < gridSize - 2; c++) {
      const i = r * gridSize + c;
      const img1 = grid[i].querySelector("img").src;
      const img2 = grid[i + 1].querySelector("img").src;
      const img3 = grid[i + 2].querySelector("img").src;
      if (img1 === img2 && img2 === img3) return true;
    }
  }
  for (let c = 0; c < gridSize; c++) {
    for (let r = 0; r < gridSize - 2; r++) {
      const i = r * gridSize + c;
      const img1 = grid[i].querySelector("img").sr
