<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>貓咪消消樂</title>
<style>
  body {
    background: linear-gradient(#ffe6cc, #fff);
    font-family: "Comic Sans MS", sans-serif;
    text-align: center;
    user-select: none;
    overflow: hidden;
  }
  h1 {
    margin-top: 20px;
    color: #d65a31;
  }
  #game {
    display: grid;
    grid-template-columns: repeat(6, 70px);
    grid-template-rows: repeat(6, 70px);
    gap: 6px;
    justify-content: center;
    margin: 20px auto;
  }
  .cell {
    width: 70px;
    height: 70px;
    border-radius: 12px;
    background-color: #fff;
    box-shadow: 0 0 6px rgba(0,0,0,0.2);
    position: relative;
    overflow: hidden;
  }
  .cell img {
    width: 65px;
    height: 65px;
    pointer-events: none;
    transition: transform 0.3s ease;
    position: relative;
  }
  .match {
    animation: pop 0.4s ease;
  }
  @keyframes pop {
    0% { transform: scale(1); }
    50% { transform: scale(1.5); }
    100% { transform: scale(0); }
  }
  #score {
    font-size: 20px;
    margin-top: 10px;
    color: #333;
  }
  #gameOver {
    display: none;
    font-size: 28px;
    color: #b00020;
    margin-top: 15px;
  }
</style>
</head>
<body>
<h1>🐾 貓咪消消樂 🐾</h1>
<div id="game"></div>
<div id="score">分數：0</div>
<div id="gameOver">🎮 遊戲結束！</div>

<!-- 音效 -->
<audio id="matchSound" src="match.mp3"></audio>
<audio id="endSound" src="end.mp3"></audio>

<script>
const gridSize = 6;
const images = ["1.png","2.png","3.png","4.png","5.png","6.png","7.png"];
let grid = [];
let score = 0;
let dragging = null;
let draggingElement = null;
let gameOver = false;

const game = document.getElementById("game");
const scoreDisplay = document.getElementById("score");
const gameOverDisplay = document.getElementById("gameOver");
const matchSound = document.getElementById("matchSound");
const endSound = document.getElementById("endSound");

// ===== 建立格子，保證初始沒有三連線 =====
function createGrid() {
  grid = [];
  game.innerHTML = "";
  for (let i = 0; i < gridSize * gridSize; i++) {
    const cell = document.createElement("div");
    cell.className = "cell";
    const img = document.createElement("img");
    let newSrc;
    do {
      newSrc = images[Math.floor(Math.random() * images.length)];
      img.src = newSrc;
    } while (createsMatch(i, newSrc));
    cell.appendChild(img);
    cell.dataset.index = i;
    addDragTouchEvents(cell);
    game.appendChild(cell);
    grid.push(cell);
  }
}

// 檢查放這個圖案會不會造成三連線
function createsMatch(index, src) {
  const r = Math.floor(index / gridSize);
  const c = index % gridSize;
  if (c >= 2) {
    const left1 = grid[index - 1]?.querySelector("img").src;
    const left2 = grid[index - 2]?.querySelector("img").src;
    if (left1 === src && left2 === src) return true;
  }
  if (r >= 2) {
    const up1 = grid[index - gridSize]?.querySelector("img").src;
    const up2 = grid[index - gridSize*2]?.querySelector("img").src;
    if (up1 === src && up2 === src) return true;
  }
  return false;
}

// ===== 拖曳事件 =====
function addDragTouchEvents(cell) {
  cell.addEventListener("mousedown", startDrag);
  cell.addEventListener("touchstart", startDrag);
  cell.addEventListener("mouseup", endDrag);
  cell.addEventListener("touchend", endDrag);
  cell.addEventListener("mousemove", moveDrag);
  cell.addEventListener("touchmove", moveDrag);
}

function startDrag(e) {
  if (gameOver) return;
  e.preventDefault();
  dragging = e.currentTarget;
  dragging.classList.add("dragging");
  draggingElement = dragging.querySelector("img").cloneNode();
  draggingElement.style.position = "fixed";
  draggingElement.style.pointerEvents = "none";
  draggingElement.style.zIndex = "1000";
  draggingElement.style.width = "65px";
  draggingElement.style.height = "65px";
  document.body.appendChild(draggingElement);
  moveDrag(e);
}

function moveDrag(e) {
  if (!draggingElement) return;
  let x, y;
  if (e.touches && e.touches[0]) {
    x = e.touches[0].clientX;
    y = e.touches[0].clientY;
  } else {
    x = e.clientX;
    y = e.clientY;
  }
  draggingElement.style.left = x - 32 + "px";
  draggingElement.style.top = y - 32 + "px";
}

function areAdjacent(cellA, cellB) {
  const i = parseInt(cellA.dataset.index);
  const j = parseInt(cellB.dataset.index);
  const r1 = Math.floor(i / gridSize), c1 = i % gridSize;
  const r2 = Math.floor(j / gridSize), c2 = j % gridSize;
  return (Math.abs(r1 - r2) + Math.abs(c1 - c2)) === 1;
}

function endDrag(e) {
  if (!dragging) return;
  dragging.classList.remove("dragging");
  if (draggingElement) { draggingElement.remove(); draggingElement = null; }

  let target = document.elementFromPoint(
    e.changedTouches ? e.changedTouches[0].clientX : e.clientX,
    e.changedTouches ? e.changedTouches[0].clientY : e.clientY
  );

  if (target && target.classList.contains("cell") && target !== dragging && areAdjacent(dragging, target)) {
    const source = dragging;
    swapCells(source, target);
    if (checkAndRemoveMatches()) {
      setTimeout(dropImages, 300);
    } else {
      setTimeout(() => swapCells(source, target), 200);
    }
  }

  dragging = null;
}

// ===== 交換格子圖案 =====
function swapCells(cellA, cellB) {
  const imgA = cellA.querySelector("img").src;
  const imgB = cellB.querySelector("img").src;
  cellA.querySelector("img").src = imgB;
  cellB.querySelector("img").src = imgA;
}

// ===== 檢查並消除連線 =====
function checkAndRemoveMatches() {
  let matched = [];
  for (let r=0; r<gridSize; r++) {
    for (let c=0; c<gridSize-2; c++) {
      const i = r*gridSize + c;
      const src1 = grid[i].querySelector("img").src;
      const src2 = grid[i+1].querySelector("img").src;
      const src3 = grid[i+2].querySelector("img").src;
      if (src1===src2 && src2===src3) matched.push(i,i+1,i+2);
    }
  }
  for (let c=0; c<gridSize; c++) {
    for (let r=0; r<gridSize-2; r++) {
      const i = r*gridSize + c;
      const src1 = grid[i].querySelector("img").src;
      const src2 = grid[i+gridSize].querySelector("img").src;
      const src3 = grid[i+gridSize*2].querySelector("img").src;
      if (src1===src2 && src2===src3) matched.push(i,i+gridSize,i+gridSize*2);
    }
  }
  matched = [...new Set(matched)];
  if (matched.length===0) return false;

  matchSound.currentTime = 0;
  matchSound.play();

  score += matched.length*10;
  scoreDisplay.textContent = "分數：" + score;

  matched.forEach(i=>{
    const img = grid[i].querySelector("img");
    img.classList.add("match");
    setTimeout(()=>{ img.src=""; img.classList.remove("match"); }, 300);
  });

  return true;
}

// ===== 圖片掉落 & 補圖 =====
function dropImages() {
  let moved = false;
  for (let c=0; c<gridSize; c++) {
    for (let r=gridSize-1; r>=0; r--) {
      const i = r*gridSize + c;
      const cell = grid[i];
      const img = cell.querySelector("img");
      if (img.src==="") {
        for (let k=r-1; k>=0; k--) {
          const aboveImg = grid[k*gridSize+c].querySelector("img");
          if (aboveImg.src!=="") {
            img.src = aboveImg.src;
            aboveImg.src = "";
            moved = true;
            break;
          }
        }
        if (img.src==="") {
          img.src = images[Math.floor(Math.random()*images.length)];
          moved = true;
        }
      }
    }
  }
  if (moved) {
    setTimeout(()=>{
      if (checkAndRemoveMatches()) setTimeout(dropImages, 300);
      else if (!hasAnyMatches()) endGame();
    }, 300);
  } else {
    if (!hasAnyMatches()) endGame();
  }
}

// ===== 是否有可消除 =====
function hasAnyMatches() {
  for (let r=0; r<gridSize; r++) {
    for (let c=0; c<gridSize-2; c++) {
      const i = r*gridSize + c;
      const src1 = grid[i].querySelector("img").src;
      const src2 = grid[i+1].querySelector("img").src;
      const src3 = grid[i+2].querySelector("img").src;
      if (src1===src2 && src2===src3) return true;
    }
  }
  for (let c=0; c<gridSize; c++) {
    for (let r=0; r<gridSize-2; r++) {
      const i = r*gridSize + c;
      const src1 = grid[i].querySelector("img").src;
      const src2 = grid[i+gridSize].querySelector("img").src;
      const src3 = grid[i+gridSize*2].querySelector("img").src;
      if (src1===src2 && src2===src3) return true;
    }
  }
  return false;
}

// ===== 遊戲結束 =====
function endGame() {
  gameOver = true;
  gameOverDisplay.style.display = "block";
  endSound.play();
}

// ===== 開始遊戲 =====
createGrid();
</script>
</body>
</html>
