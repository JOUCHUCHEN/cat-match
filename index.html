<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>喵嗚值消消樂（修正下落）</title>
<style>
  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
    background: #f8f8f8;
    margin: 0;
    user-select: none;
    touch-action: none;
  }
  #board {
    display: grid;
    grid-template-columns: repeat(8, 65px);
    grid-template-rows: repeat(8, 65px);
    gap: 4px;
  }
  .cell {
    width: 65px;
    height: 65px;
    background-size: cover;
    border-radius: 10px;
    transition: transform 0.5s ease, background-image 0.3s ease;
  }
  #score {
    font-size: 24px;
    font-weight: bold;
    margin-bottom: 10px;
  }
</style>
</head>
<body>

<div id="score">喵嗚值：0</div>
<div id="board"></div>

<script>
const rows = 8, cols = 8;
const icons = [
  "1.png","2.png","3.png","4.png","5.png","6.png","7.png"
];
let board = [];
let score = 0;
let dragging = false;
let startCell = null;
const scoreEl = document.getElementById("score");

function randomIcon(){
  return icons[Math.floor(Math.random()*icons.length)];
}

function initBoard(){
  board = [];
  for(let r=0;r<rows;r++){
    board[r] = [];
    for(let c=0;c<cols;c++){
      let icon;
      do{
        icon = randomIcon();
        board[r][c] = icon;
      }while(checkInitialMatch(r,c));
    }
  }
  renderBoard();
}

function checkInitialMatch(r,c){
  if(c>=2 && board[r][c]===board[r][c-1] && board[r][c]===board[r][c-2]) return true;
  if(r>=2 && board[r][c]===board[r-1][c] && board[r][c]===board[r-2][c]) return true;
  return false;
}

function renderBoard(){
  const boardDiv = document.getElementById("board");
  boardDiv.innerHTML = "";
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const cell = document.createElement("div");
      cell.className = "cell";
      cell.dataset.row = r;
      cell.dataset.col = c;
      if(board[r][c]) cell.style.backgroundImage = `url(${board[r][c]})`;
      else cell.style.backgroundImage = "none";
      addEvent(cell);
      boardDiv.appendChild(cell);
    }
  }
}

function addEvent(cell){
  cell.addEventListener("mousedown",startDrag);
  cell.addEventListener("touchstart",startDrag);
  cell.addEventListener("mouseup",endDrag);
  cell.addEventListener("touchend",endDrag);
}

function startDrag(e){
  e.preventDefault();
  dragging = true;
  startCell = e.target;
}

function endDrag(e){
  if(!dragging) return;
  dragging = false;
  const endCell = document.elementFromPoint(
    e.changedTouches ? e.changedTouches[0].clientX : e.clientX,
    e.changedTouches ? e.changedTouches[0].clientY : e.clientY
  );
  if(!endCell || !endCell.classList.contains("cell")) return;

  const r1 = +startCell.dataset.row;
  const c1 = +startCell.dataset.col;
  const r2 = +endCell.dataset.row;
  const c2 = +endCell.dataset.col;

  if(Math.abs(r1-r2)+Math.abs(c1-c2)===1){
    swapCellsAnimated(r1,c1,r2,c2);
  }
}

function swapCellsAnimated(r1,c1,r2,c2){
  const cell1 = document.querySelector(`.cell[data-row="${r1}"][data-col="${c1}"]`);
  const cell2 = document.querySelector(`.cell[data-row="${r2}"][data-col="${c2}"]`);
  const temp = board[r1][c1];
  board[r1][c1] = board[r2][c2];
  board[r2][c2] = temp;

  cell1.style.transition = "transform 0.3s";
  cell2.style.transition = "transform 0.3s";
  const dx = (c2-c1)*69;
  const dy = (r2-r1)*69;
  cell1.style.transform = `translate(${dx}px,${dy}px)`;
  cell2.style.transform = `translate(${-dx}px,${-dy}px)`;

  setTimeout(()=>{
    cell1.style.transition = "";
    cell2.style.transition = "";
    cell1.style.transform = "";
    cell2.style.transform = "";
    renderBoard();
    handleMatches();
  },300);
}

function handleMatches(){
  const matches = checkMatches();
  if(matches.length>0){
    clearMatches(matches);
    setTimeout(()=>{
      applyGravity();
    },300);
  }else if(!hasPossibleMove()){
    gameOver();
  }
}

function checkMatches(){
  const matches = [];
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const icon = board[r][c];
      if(!icon) continue;
      if(c<cols-2 && board[r][c+1]===icon && board[r][c+2]===icon){
        let len=3;
        while(c+len<cols && board[r][c+len]===icon) len++;
        for(let k=0;k<len;k++) matches.push([r,c+k]);
      }
      if(r<rows-2 && board[r+1][c]===icon && board[r+2][c]===icon){
        let len=3;
        while(r+len<rows && board[r+len][c]===icon) len++;
        for(let k=0;k<len;k++) matches.push([r+k,c]);
      }
    }
  }
  return matches;
}

function clearMatches(matches){
  const cleared = {};
  matches.forEach(([r,c])=>{
    const key = r+'-'+c;
    if(!cleared[key]) cleared[key] = true;
  });
  const countMap = {};
  for(const key in cleared){
    const [r,c] = key.split('-').map(Number);
    const icon = board[r][c];
    countMap[icon] = (countMap[icon]||0)+1;
  }
  let addScore = 0;
  for(const icon in countMap){
    const n = countMap[icon];
    if(n===3) addScore += 1*3;
    else if(n===4) addScore += 2*4;
    else if(n>=5) addScore += 3*n;
  }
  score += addScore;
  scoreEl.textContent = "喵嗚值：" + score;

  matches.forEach(([r,c])=>{
    board[r][c] = null;
    const cell = document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
    if(cell) cell.style.backgroundImage = "none";
  });
}

// ===== 修正版 applyGravity()：同步滑落（保留其他程式碼不變） =====
function applyGravity(){
  // 目標：讓所有「原本應下落的格子」與「新補的格子」同步滑落（一起 0.5s）
  // 實作步驟：
  // 1) snapshot boardBefore（由當前 DOM 讀出）
  // 2) 計算每列 emptySpots（以 boardBefore 計算），為每列產生 newIcons 陣列
  // 3) 為每個原有要下滑的格子計算 dy，並收集要動畫的 element
  // 4) 為每個新圖建立 fixed clone（在畫面外上方），加入動畫隊列
  // 5) 同步觸發動畫（0.5s），結束後把 board 更新為 newBoard，renderBoard()

  // 1) snapshot boardBefore from DOM
  const boardBefore = [];
  const domCells = Array.from(document.querySelectorAll('.cell'));
  for(let r=0;r<rows;r++){
    boardBefore[r] = [];
    for(let c=0;c<cols;c++){
      const el = document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
      const bg = el ? el.style.backgroundImage : "";
      if(bg && bg !== "none") {
        const m = bg.match(/url\(["']?(.*?)["']?\)/);
        boardBefore[r][c] = m ? m[1] : bg;
      } else {
        boardBefore[r][c] = null;
      }
    }
  }

  // cell size and gap (read from DOM to be robust)
  const sample = document.querySelector('.cell');
  const cellH = sample ? sample.getBoundingClientRect().height : 65;
  const cellW = sample ? sample.getBoundingClientRect().width : 65;
  // read gap from computed style of grid (approximation)
  let gap = 4;
  const boardDiv = document.getElementById("board");
  const cs = window.getComputedStyle(boardDiv);
  if(cs && cs.getPropertyValue("gap")) {
    gap = parseFloat(cs.getPropertyValue("gap")) || gap;
  }

  // 2) compute emptySpots and newIcons for each column
  const newIconsByCol = Array.from({length: cols}, () => []);
  const emptyCountByCol = Array(cols).fill(0);
  for(let c=0;c<cols;c++){
    let empty = 0;
    for(let r=rows-1;r>=0;r--){
      if(boardBefore[r][c] === null) empty++;
    }
    emptyCountByCol[c] = empty;
    for(let i=0;i<empty;i++){
      newIconsByCol[c].push(randomIcon());
    }
  }

  // 3) compute movements for existing cells (collect elements and dy)
  const moves = []; // {el, dy}
  for(let c=0;c<cols;c++){
    let emptyBelow = 0;
    for(let r=rows-1;r>=0;r--){
      if(boardBefore[r][c] === null){
        emptyBelow++;
      } else {
        if(emptyBelow>0){
          const srcEl = document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
          const tgtRow = r + emptyBelow;
          const tgtEl = document.querySelector(`.cell[data-row="${tgtRow}"][data-col="${c}"]`);
          if(srcEl && tgtEl){
            const srcRect = srcEl.getBoundingClientRect();
            const tgtRect = tgtEl.getBoundingClientRect();
            const dy = tgtRect.top - srcRect.top;
            moves.push({el: srcEl, dy});
          } else if(srcEl){
            // if target element missing (edge cases), still move by emptyBelow * (cellH+gap)
            const dy = emptyBelow * (cellH + gap);
            moves.push({el: srcEl, dy});
          }
        }
      }
    }
  }

  // 4) create clones for new icons, positioned above and animate down to their target slots
  const clones = [];
  for(let c=0;c<cols;c++){
    const empty = emptyCountByCol[c];
    if(empty<=0) continue;
    // For target rows 0..empty-1, we will create clones that start above and go to their positions
    for(let i=0;i<empty;i++){
      const targetRow = i; // after gravity, top rows will be filled with newIcons in order
      const targetEl = document.querySelector(`.cell[data-row="${targetRow}"][data-col="${c}"]`);
      if(!targetEl) continue;
      const tgtRect = targetEl.getBoundingClientRect();
      // starting position: above by empty * (cellH+gap)
      const startTop = tgtRect.top - (empty * (cellH + gap));
      const left = tgtRect.left;
      const clone = document.createElement('div');
      clone.className = 'cell';
      clone.style.position = 'fixed';
      clone.style.left = left + 'px';
      clone.style.top = startTop + 'px';
      clone.style.width = tgtRect.width + 'px';
      clone.style.height = tgtRect.height + 'px';
      clone.style.backgroundImage = `url(${newIconsByCol[c][i]})`;
      clone.style.zIndex = 999;
      // animate by translate
      const dy = (tgtRect.top - startTop);
      // set initial transform 0, then translate to dy
      clone.style.transform = `translateY(${0}px)`;
      clone.style.transition = "transform 0.5s ease";
      document.body.appendChild(clone);
      // force reflow to ensure transition starts
      void clone.offsetWidth;
      clone.style.transform = `translateY(${dy}px)`;
      clones.push(clone);
    }
  }

  // 5) trigger moves for existing cells
  moves.forEach(m=>{
    m.el.style.transition = "transform 0.5s ease";
    m.el.style.transform = `translateY(${m.dy}px)`;
  });

  // 6) after animation, remove clones, reset transforms, update board to new state and renderBoard
  setTimeout(()=>{
    clones.forEach(cl=>cl.remove());
    moves.forEach(m=>{
      m.el.style.transition = "";
      m.el.style.transform = "";
    });

    // build newBoard from boardBefore + newIconsByCol
    const newBoard = Array.from({length: rows}, () => Array(cols).fill(null));
    for(let c=0;c<cols;c++){
      // collect existing icons in this column from boardBefore, top->bottom
      const existing = [];
      for(let r=0;r<rows;r++){
        if(boardBefore[r][c] !== null) existing.push(boardBefore[r][c]);
      }
      // place existing from bottom up
      let writeRow = rows-1;
      for(let k=existing.length-1;k>=0;k--){
        newBoard[writeRow][c] = existing[k];
        writeRow--;
      }
      // fill remaining top slots with newIconsByCol[c] in order (top to bottom)
      const empties = writeRow + 1;
      // newIconsByCol[c] has length = empties
      for(let i=0;i<empties;i++){
        newBoard[i][c] = newIconsByCol[c][i];
      }
    }

    // replace board with newBoard
    board = newBoard;
    renderBoard();

    // continue chain: check new matches
    const newMatches = checkMatches();
    if(newMatches.length>0){
      setTimeout(()=>{ clearMatches(newMatches); setTimeout(()=>applyGravity(),300); },100);
    } else if(!hasPossibleMove()){
      gameOver();
    }

  }, 500);

  return true;
}
// ===== end applyGravity() 修正版 =====

function hasPossibleMove(){
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      if(r<rows-1){
        swapSimple(r,c,r+1,c);
        if(checkMatches().length>0){swapSimple(r,c,r+1,c);return true;}
        swapSimple(r,c,r+1,c);
      }
      if(c<cols-1){
        swapSimple(r,c,r,c+1);
        if(checkMatches().length>0){swapSimple(r,c,r,c+1);return true;}
        swapSimple(r,c,r,c+1);
      }
    }
  }
  return false;
}

function swapSimple(r1,c1,r2,c2){
  [board[r1][c1],board[r2][c2]]=[board[r2][c2],board[r1][c1]];
}

function gameOver(){
  alert("遊戲結束！最終喵嗚值：" + score);
}

// start
initBoard();
</script>

</body>
</html>
