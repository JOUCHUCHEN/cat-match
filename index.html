<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>喵嗚值消消樂v1</title>
<style>
  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
    background: #f8f8f8;
    margin: 0;
    user-select: none;
    touch-action: none;
  }
  #board {
    display: grid;
    grid-template-columns: repeat(8, 65px);
    grid-template-rows: repeat(8, 65px);
    gap: 4px;
    overflow: hidden; /* ✅ 防止新圖在框外可見 */
  }
  .cell {
    width: 65px;
    height: 65px;
    background-size: cover;
    border-radius: 10px;
    transition: transform 0.5s ease, background-image 0.3s ease, opacity 0.2s ease;
  }
  #score {
    font-size: 24px;
    font-weight: bold;
    margin-bottom: 10px;
  }
</style>
</head>
<body>

<div id="score">喵嗚值：0</div>
<div id="board"></div>

<script>
const rows = 8, cols = 8;
const icons = [
  "1.png","2.png","3.png","4.png","5.png","6.png","7.png"
];
let board = [];
let score = 0;
let dragging = false;
let startCell = null;
const scoreEl = document.getElementById("score");

function randomIcon(){
  return icons[Math.floor(Math.random()*icons.length)];
}

function initBoard(){
  board = [];
  for(let r=0;r<rows;r++){
    board[r] = [];
    for(let c=0;c<cols;c++){
      let icon;
      do{
        icon = randomIcon();
        board[r][c] = icon;
      }while(checkInitialMatch(r,c));
    }
  }
  renderBoard();
}

function checkInitialMatch(r,c){
  if(c>=2 && board[r][c]===board[r][c-1] && board[r][c]===board[r][c-2]) return true;
  if(r>=2 && board[r][c]===board[r-1][c] && board[r][c]===board[r-2][c]) return true;
  return false;
}

function renderBoard(){
  const boardDiv = document.getElementById("board");
  boardDiv.innerHTML = "";
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const cell = document.createElement("div");
      cell.className = "cell";
      cell.dataset.row = r;
      cell.dataset.col = c;
      cell.style.backgroundImage = `url(${board[r][c]})`;
      addEvent(cell);
      boardDiv.appendChild(cell);
    }
  }
}

function addEvent(cell){
  cell.addEventListener("mousedown",startDrag);
  cell.addEventListener("touchstart",startDrag);
  cell.addEventListener("mouseup",endDrag);
  cell.addEventListener("touchend",endDrag);
}

function startDrag(e){
  e.preventDefault();
  dragging = true;
  startCell = e.target;
}

function endDrag(e){
  if(!dragging) return;
  dragging = false;
  const endCell = document.elementFromPoint(
    e.changedTouches ? e.changedTouches[0].clientX : e.clientX,
    e.changedTouches ? e.changedTouches[0].clientY : e.clientY
  );
  if(!endCell || !endCell.classList.contains("cell")) return;

  const r1 = +startCell.dataset.row;
  const c1 = +startCell.dataset.col;
  const r2 = +endCell.dataset.row;
  const c2 = +endCell.dataset.col;

  if(Math.abs(r1-r2)+Math.abs(c1-c2)===1){
    swapCellsAnimated(r1,c1,r2,c2);
  }
}

function swapCellsAnimated(r1,c1,r2,c2){
  const cell1 = document.querySelector(`.cell[data-row="${r1}"][data-col="${c1}"]`);
  const cell2 = document.querySelector(`.cell[data-row="${r2}"][data-col="${c2}"]`);
  const temp = board[r1][c1];
  board[r1][c1] = board[r2][c2];
  board[r2][c2] = temp;

  cell1.style.transition = "transform 0.3s";
  cell2.style.transition = "transform 0.3s";
  const dx = (c2-c1)*69;
  const dy = (r2-r1)*69;
  cell1.style.transform = `translate(${dx}px,${dy}px)`;
  cell2.style.transform = `translate(${-dx}px,${-dy}px)`;

  setTimeout(()=>{
    cell1.style.transition = "";
    cell2.style.transition = "";
    cell1.style.transform = "";
    cell2.style.transform = "";
    renderBoard();
    handleMatches();
  },300);
}

function handleMatches(){
  const matches = checkMatches();
  if(matches.length>0){
    clearMatches(matches);
    setTimeout(()=>{
      applyGravity();
    },300);
  }else if(!hasPossibleMove()){
    gameOver();
  }
}

function checkMatches(){
  const matches = [];
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const icon = board[r][c];
      if(!icon) continue;
      if(c<cols-2 && board[r][c+1]===icon && board[r][c+2]===icon){
        let len=3;
        while(c+len<cols && board[r][c+len]===icon) len++;
        for(let k=0;k<len;k++) matches.push([r,c+k]);
      }
      if(r<rows-2 && board[r+1][c]===icon && board[r+2][c]===icon){
        let len=3;
        while(r+len<rows && board[r+len][c]===icon) len++;
        for(let k=0;k<len;k++) matches.push([r+k,c]);
      }
    }
  }
  return matches;
}

function clearMatches(matches){
  const cleared = {};
  matches.forEach(([r,c])=>{
    const key = r+'-'+c;
    if(!cleared[key]) cleared[key] = true;
  });
  const countMap = {};
  for(const key in cleared){
    const [r,c] = key.split('-').map(Number);
    const icon = board[r][c];
    countMap[icon] = (countMap[icon]||0)+1;
  }
  let addScore = 0;
  for(const icon in countMap){
    const n = countMap[icon];
    if(n===3) addScore += 1*3;
    else if(n===4) addScore += 2*4;
    else if(n>=5) addScore += 3*n;
  }
  score += addScore;
  scoreEl.textContent = "喵嗚值：" + score;

  matches.forEach(([r,c])=>{
    board[r][c] = null;
    const cell = document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
    if(cell) cell.style.backgroundImage = "none";
  });
}

// ✅ 修正版：新補圖在格內才出現
function applyGravity(){
  let moved = false;
  const cellsToMove = [];

  for(let c=0;c<cols;c++){
    let emptySpots = 0;
    for(let r=rows-1;r>=0;r--){
      if(board[r][c]===null){
        emptySpots++;
      } else if(emptySpots>0){
        const cell = document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
        if(cell){
          const dy = emptySpots * cell.offsetHeight;
          cellsToMove.push({cell, dy});
        }
        board[r+emptySpots][c] = board[r][c];
        board[r][c] = null;
        moved = true;
      }
    }

    // 新補圖：起始時隱藏，滑入格內才顯示
    for(let i=0;i<emptySpots;i++){
      const newIcon = icons[Math.floor(Math.random()*icons.length)];
      board[i][c] = newIcon;

      const newCell = document.createElement('div');
      newCell.className = 'cell';
      newCell.dataset.row = i;
      newCell.dataset.col = c;
      newCell.style.backgroundImage = `url(${newIcon})`;
      newCell.style.transform = `translateY(${-(emptySpots-i+1)*65}px)`;
      newCell.style.opacity = "0"; // ✅ 一開始不可見
      document.getElementById("board").appendChild(newCell);
      addEvent(newCell);

      const dy = (emptySpots - i + 1) * newCell.offsetHeight;
      cellsToMove.push({cell: newCell, dy});
    }
  }

  // 滑落動畫
  cellsToMove.forEach(item=>{
    item.cell.style.transition = "transform 0.5s ease, opacity 0.2s ease";
    item.cell.style.transform = `translateY(${item.dy}px)`;
    setTimeout(()=> item.cell.style.opacity = "1", 200); // ✅ 滑入後才顯示
  });

  setTimeout(()=>{
    cellsToMove.forEach(item=>{
      item.cell.style.transition = "";
      item.cell.style.transform = "";
    });
    renderBoard();
    handleMatches();
  },500);

  return moved;
}

function hasPossibleMove(){
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      if(r<rows-1){
        swapSimple(r,c,r+1,c);
        if(checkMatches().length>0){swapSimple(r,c,r+1,c);return true;}
        swapSimple(r,c,r+1,c);
      }
      if(c<cols-1){
        swapSimple(r,c,r,c+1);
        if(checkMatches().length>0){swapSimple(r,c,r,c+1);return true;}
        swapSimple(r,c,r,c+1);
      }
    }
  }
  return false;
}

function swapSimple(r1,c1,r2,c2){
  [board[r1][c1],board[r2][c2]]=[board[r2][c2],board[r1][c1]];
}

function gameOver(){
  alert("遊戲結束！最終喵嗚值：" + score);
}

initBoard();
</script>
</body>
</html>
