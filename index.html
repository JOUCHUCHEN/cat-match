<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>æŠ—å¦–æ¶ˆæ¶ˆæ¨‚</title>
<style>
  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
    background: #222;
    color: white;
    font-family: "Microsoft JhengHei", sans-serif;
    margin: 0;
  }

  h1 { margin-bottom: 10px; }

  #score {
    font-size: 1.5em;
    margin-bottom: 10px;
  }

  #board {
    display: grid;
    grid-template-columns: repeat(6, 60px);
    grid-template-rows: repeat(6, 60px);
    gap: 5px;
    touch-action: none;
  }

  .cell {
    width: 60px;
    height: 60px;
    background-size: cover;
    border-radius: 10px;
    transition: transform 0.3s, opacity 0.3s;
  }

  .highlight {
    transform: scale(1.1);
  }

  #gameOver {
    font-size: 2em;
    color: #ff6666;
    display: none;
    margin-top: 20px;
  }

  #restart {
    display: none;
    margin-top: 10px;
    padding: 10px 20px;
    background: #4CAF50;
    border: none;
    color: white;
    border-radius: 8px;
    font-size: 1em;
  }
</style>
</head>
<body>
  <h1>æŠ—å¦–æ¶ˆæ¶ˆæ¨‚</h1>
  <div id="score">æŠ—å¦–å€¼ï¼š0</div>
  <div id="board"></div>
  <div id="gameOver">ğŸ‘¾ éŠæˆ²çµæŸï¼</div>
  <button id="restart">é‡æ–°é–‹å§‹</button>

<script>
const rows = 6, cols = 6, types = 6;
let board = [];
let score = 0;
let dragStart = null;

const boardEl = document.getElementById("board");
const scoreEl = document.getElementById("score");
const gameOverEl = document.getElementById("gameOver");
const restartBtn = document.getElementById("restart");

function randomType() {
  return Math.floor(Math.random() * types) + 1;
}

function initBoard() {
  do {
    board = Array.from({ length: rows }, () =>
      Array.from({ length: cols }, () => randomType())
    );
  } while (checkMatches().length > 0); // é‡æ´—ç›´åˆ°æ²’æœ‰åˆå§‹ä¸‰é€£

  score = 0;
  scoreEl.textContent = `æŠ—å¦–å€¼ï¼š${score}`;
  renderBoard();
}

function renderBoard() {
  boardEl.innerHTML = "";
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const div = document.createElement("div");
      div.classList.add("cell");

      // æ”¯æ´å¤§å°å¯«å‰¯æª”åï¼ˆPNG æˆ– pngï¼‰
      const imgName = board[r][c];
      const srcLower = `${imgName}.png`;
      const srcUpper = `${imgName}.PNG`;

      const img = new Image();
      img.src = srcLower;
      img.onerror = () => { div.style.backgroundImage = `url(${srcUpper})`; };
      img.onload = () => { div.style.backgroundImage = `url(${srcLower})`; };

      div.dataset.row = r;
      div.dataset.col = c;
      boardEl.appendChild(div);
    }
  }
}

function swap(r1, c1, r2, c2) {
  [board[r1][c1], board[r2][c2]] = [board[r2][c2], board[r1][c1]];
}

function checkMatches() {
  let matched = [];
  // æ©«å‘
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols - 2; c++) {
      const t = board[r][c];
      if (t && t === board[r][c+1] && t === board[r][c+2]) {
        let temp = [[r,c],[r,c+1],[r,c+2]];
        let cc = c+3;
        while (cc < cols && board[r][cc] === t) {
          temp.push([r,cc]);
          cc++;
        }
        matched = matched.concat(temp);
        c = cc-1;
      }
    }
  }
  // ç¸±å‘
  for (let c = 0; c < cols; c++) {
    for (let r = 0; r < rows - 2; r++) {
      const t = board[r][c];
      if (t && t === board[r+1][c] && t === board[r+2][c]) {
        let temp = [[r,c],[r+1,c],[r+2,c]];
        let rr = r+3;
        while (rr < rows && board[rr][c] === t) {
          temp.push([rr,c]);
          rr++;
        }
        matched = matched.concat(temp);
        r = rr-1;
      }
    }
  }
  return matched;
}

function removeMatches() {
  let matches = checkMatches();
  if (matches.length === 0) {
    if (!canMove()) {
      gameOverEl.style.display = "block";
      restartBtn.style.display = "inline-block";
    }
    return;
  }

  let cells = document.querySelectorAll(".cell");
  matches.forEach(([r, c]) => {
    const idx = r * cols + c;
    const cell = cells[idx];
    if (cell) {
      cell.classList.add("highlight");
      setTimeout(() => { cell.style.opacity = "0"; }, 200);
    }
    board[r][c] = null;
  });

  score += matches.length;
  scoreEl.textContent = `æŠ—å¦–å€¼ï¼š${score}`;
  setTimeout(dropAndFill, 400);
}

function dropAndFill() {
  for (let c = 0; c < cols; c++) {
    for (let r = rows - 1; r >= 0; r--) {
      if (!board[r][c]) {
        for (let rr = r - 1; rr >= 0; rr--) {
          if (board[rr][c]) {
            board[r][c] = board[rr][c];
            board[rr][c] = null;
            break;
          }
        }
        if (!board[r][c]) board[r][c] = randomType();
      }
    }
  }
  renderBoard();
  setTimeout(removeMatches, 200);
}

function canMove() {
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      if (c < cols - 1) {
        swap(r, c, r, c + 1);
        if (checkMatches().length > 0) { swap(r, c, r, c + 1); return true; }
        swap(r, c, r, c + 1);
      }
      if (r < rows - 1) {
        swap(r, c, r + 1, c);
        if (checkMatches().length > 0) { swap(r, c, r + 1, c); return true; }
        swap(r, c, r + 1, c);
      }
    }
  }
  return false;
}

function getCell(e) {
  const touch = e.touches ? e.touches[0] : e;
  const target = document.elementFromPoint(touch.clientX, touch.clientY);
  if (!target || !target.classList.contains("cell")) return null;
  return target;
}

boardEl.addEventListener("mousedown", startDrag);
boardEl.addEventListener("touchstart", startDrag);
boardEl.addEventListener("mouseup", endDrag);
boardEl.addEventListener("touchend", endDrag);

function startDrag(e) {
  const cell = getCell(e);
  if (!cell) return;
  dragStart = { row: +cell.dataset.row, col: +cell.dataset.col };
  cell.classList.add("highlight");
}

function endDrag(e) {
  if (!dragStart) return;
  const start = dragStart;
  const endCell = getCell(e);
  document.querySelectorAll(".cell").forEach(c => c.classList.remove("highlight"));
  if (!endCell) { dragStart = null; return; }

  const end = { row: +endCell.dataset.row, col: +endCell.dataset.col };
  const dr = end.row - start.row;
  const dc = end.col - start.col;

  if (Math.abs(dr) + Math.abs(dc) !== 1) { dragStart = null; return; }

  swap(start.row, start.col, end.row, end.col);
  renderBoard();

  setTimeout(() => {
    if (checkMatches().length === 0) {
      swap(start.row, start.col, end.row, end.col);
      renderBoard();
    } else {
      removeMatches();
    }
  }, 200);

  dragStart = null;
}

restartBtn.addEventListener("click", () => {
  gameOverEl.style.display = "none";
  restartBtn.style.display = "none";
  initBoard();
});

initBoard();
</script>
</body>
</html>
