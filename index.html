<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>喵嗚消消樂 8x8 v3</title>
<style>
body {
  text-align: center;
  background: #222;
  color: #fff;
  font-family: "微軟正黑體";
  margin: 0;
  padding: 0;
  overflow-x: hidden;
}

#game {
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  grid-template-rows: repeat(8, 1fr);
  gap: 1.2vw;
  justify-content: center;
  width: 90vw;
  max-width: 480px;
  aspect-ratio: 1/1;
  margin: 20px auto;
  position: relative;
  touch-action: none;
}

.cell {
  width: 100%;
  height: 100%;
  background-size: cover;
  background-position: center;
  border-radius: 10%;
  cursor: grab;
  position: relative;
  transition: transform 0.5s ease, background-image 0.5s ease;
}

.cell.dragging {
  transform: scale(1.2);
  z-index: 10;
}

.score {
  font-size: 5vw;
  margin-top: 3vw;
}

.plus-text {
  position: fixed;
  font-size: 4vw;
  color: #ffdd00;
  font-weight: bold;
  animation: floatUp 0.8s ease-out forwards;
  pointer-events: none;
}

@keyframes floatUp {
  0% {opacity:1; transform:translateY(0);}
  100% {opacity:0; transform:translateY(-40px);}
}

@media (min-width: 600px) {
  .score { font-size: 22px; }
  .plus-text { font-size: 18px; }
}
</style>
</head>
<body>

<h2>喵嗚消消樂 8x8</h2>
<div class="score">喵嗚值：<span id="score">0</span></div>
<div id="game"></div>

<script>
const rows = 8, cols = 8;
const icons = ["1.png","2.png","3.png","4.png","5.png","6.png","7.png"];
let board = [];
let score = 0;

const game = document.getElementById("game");
const scoreEl = document.getElementById("score");

function randomIcon() {
  return icons[Math.floor(Math.random() * icons.length)];
}

function initBoard() {
  do {
    board = [];
    for (let r = 0; r < rows; r++) {
      const row = [];
      for (let c = 0; c < cols; c++) {
        row.push(randomIcon());
      }
      board.push(row);
    }
  } while (checkMatches().length > 0);
  renderBoard();
}

function renderBoard() {
  game.innerHTML = "";
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const cell = document.createElement("div");
      cell.classList.add("cell");
      cell.style.backgroundImage = `url("${board[r][c]}")`;
      cell.dataset.row = r;
      cell.dataset.col = c;
      addDragEvents(cell);
      game.appendChild(cell);
    }
  }
}

let startRow, startCol, currentCell;

function addDragEvents(cell) {
  cell.addEventListener("mousedown", dragStart);
  cell.addEventListener("touchstart", dragStart, {passive:false});
}

function dragStart(e) {
  e.preventDefault();
  currentCell = e.target;
  currentCell.classList.add("dragging");
  startRow = +currentCell.dataset.row;
  startCol = +currentCell.dataset.col;

  document.addEventListener("mousemove", dragMove);
  document.addEventListener("mouseup", dragEnd);
  document.addEventListener("touchmove", dragMove, {passive:false});
  document.addEventListener("touchend", dragEnd);
}

function dragMove(e) {
  if (!currentCell) return;
  const x = e.touches ? e.touches[0].clientX : e.clientX;
  const y = e.touches ? e.touches[0].clientY : e.clientY;
  const over = document.elementFromPoint(x, y);
  if (!over || !over.classList.contains("cell")) return;

  const endRow = +over.dataset.row;
  const endCol = +over.dataset.col;
  const dr = Math.abs(endRow - startRow);
  const dc = Math.abs(endCol - startCol);

  // 僅允許相鄰交換
  if ((dr + dc) === 1) {
    animateSwap(startRow, startCol, endRow, endCol, () => {
      const matches = checkMatches();
      if (matches.length > 0) {
        handleMatches(matches);
      } else {
        animateSwap(endRow, endCol, startRow, startCol); // 交換回來
      }
    });
    dragEnd();
  }
}

function dragEnd() {
  if (currentCell) currentCell.classList.remove("dragging");
  currentCell = null;
  document.removeEventListener("mousemove", dragMove);
  document.removeEventListener("mouseup", dragEnd);
  document.removeEventListener("touchmove", dragMove);
  document.removeEventListener("touchend", dragEnd);
}

// 🔹 加入交換動畫
function animateSwap(r1, c1, r2, c2, callback) {
  const cell1 = document.querySelector(`.cell[data-row="${r1}"][data-col="${c1}"]`);
  const cell2 = document.querySelector(`.cell[data-row="${r2}"][data-col="${c2}"]`);
  if (!cell1 || !cell2) return;

  const rect1 = cell1.getBoundingClientRect();
  const rect2 = cell2.getBoundingClientRect();
  const dx = rect2.left - rect1.left;
  const dy = rect2.top - rect1.top;

  // 動畫過程
  cell1.style.transition = "transform 0.25s ease";
  cell2.style.transition = "transform 0.25s ease";
  cell1.style.transform = `translate(${dx}px, ${dy}px)`;
  cell2.style.transform = `translate(${-dx}px, ${-dy}px)`;

  setTimeout(() => {
    cell1.style.transition = "";
    cell2.style.transition = "";
    cell1.style.transform = "";
    cell2.style.transform = "";
    swapCellsSimple(r1, c1, r2, c2);
    renderBoard();
    if (callback) callback();
  }, 250);
}

function swapCellsSimple(r1,c1,r2,c2){
  [board[r1][c1],board[r2][c2]]=[board[r2][c2],board[r1][c1]];
}

// 🔹 找出所有連線組
function checkMatches() {
  const matches = [];
  // 橫向
  for (let r=0;r<rows;r++){
    let count=1;
    for (let c=1;c<cols;c++){
      if(board[r][c]===board[r][c-1]) count++;
      else {
        if(count>=3) matches.push({row:r, start:c-count, end:c-1});
        count=1;
      }
    }
    if(count>=3) matches.push({row:r, start:cols-count, end:cols-1});
  }
  // 直向
  for (let c=0;c<cols;c++){
    let count=1;
    for (let r=1;r<rows;r++){
      if(board[r][c]===board[r-1][c]) count++;
      else {
        if(count>=3) matches.push({col:c, start:r-count, end:r-1});
        count=1;
      }
    }
    if(count>=3) matches.push({col:c, start:rows-count, end:rows-1});
  }
  return matches;
}

// 🔹 依組大小給分 (+1, +2, +3)
function clearMatches(matches){
  const cleared = new Set();
  let totalAdd = 0;
  matches.forEach(m=>{
    let cells = [];
    if(m.row!==undefined){
      for(let c=m.start;c<=m.end;c++) cells.push([m.row,c]);
    } else {
      for(let r=m.start;r<=m.end;r++) cells.push([r,m.col]);
    }
    const groupSize = cells.length;
    const add = groupSize>=5?3:groupSize===4?2:1;
    totalAdd += add;
    cells.forEach(([r,c])=>{
      const key = r+'-'+c;
      if(!cleared.has(key)){
        board[r][c]=null;
        showPlusEffect(r,c,add);
        cleared.add(key);
      }
    });
  });
  score += totalAdd;
  scoreEl.textContent = score;
}

function applyGravity(){
  let moved=false;
  for(let c=0;c<cols;c++){
    for(let r=rows-1;r>=0;r--){
      if(board[r][c]===null){
        let upper=r-1;
        while(upper>=0 && board[upper][c]===null) upper--;
        if(upper>=0){
          board[r][c]=board[upper][c];
          board[upper][c]=null;
          moved=true;
        }
      }
    }
  }
  renderBoard();
  return moved;
}

function refillBoard(){
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      if(board[r][c]===null){
        board[r][c]=randomIcon();
      }
    }
  }
  renderBoard();
}

function handleMatches(matches){
  clearMatches(matches);
  setTimeout(()=>{
    let moved=applyGravity();
    setTimeout(()=>{
      refillBoard();
      const newMatches=checkMatches();
      if(newMatches.length>0) handleMatches(newMatches);
      else if(!hasPossibleMoves()) gameOver();
    }, moved?250:0);
  },350);
}

function showPlusEffect(r,c,add){
  const cell=document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
  if(!cell) return;
  const rect=cell.getBoundingClientRect();
  const plus=document.createElement("div");
  plus.classList.add("plus-text");
  plus.textContent="+"+add;
  plus.style.left=rect.left+"px";
  plus.style.top=rect.top+"px";
  document.body.appendChild(plus);
  setTimeout(()=>plus.remove(),800);
}

function hasPossibleMoves(){
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      if(r<rows-1){ swapCellsSimple(r,c,r+1,c); if(checkMatches().length>0){swapCellsSimple(r,c,r+1,c); return true;} swapCellsSimple(r,c,r+1,c); }
      if(c<cols-1){ swapCellsSimple(r,c,r,c+1); if(checkMatches().length>0){swapCellsSimple(r,c,r,c+1); return true;} swapCellsSimple(r,c,r,c+1); }
    }
  }
  return false;
}

function gameOver(){
  alert("遊戲結束！最終喵嗚值：" + score);
}

initBoard();
</script>

</body>
</html>
