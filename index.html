<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>æ»‘é¼ +æ‰‹æ©Ÿæ¶ˆæ¶ˆæ¨‚</title>
<style>
  body {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    background: #fafafa;
    font-family: sans-serif;
    flex-direction: column;
  }
  #board {
    display: grid;
    grid-template-columns: repeat(6, 64px);
    grid-template-rows: repeat(6, 64px);
    gap: 4px;
  }
  .cell {
    width: 64px;
    height: 64px;
    background-size: cover;
    border-radius: 8px;
    transition: transform 0.2s;
  }
  #message {
    margin-top: 10px;
    font-size: 20px;
    color: #444;
  }
</style>
</head>
<body>
<h2>æ»‘é¼ +æ‰‹æ©Ÿæ¶ˆæ¶ˆæ¨‚</h2>
<div id="board"></div>
<div id="message"></div>

<script>
const size = 6;
const types = 6;
let board = [];
let dragging = null;
let isSwapping = false;
const boardEl = document.getElementById("board");
const message = document.getElementById("message");

function randomTile() {
  return Math.floor(Math.random() * types) + 1;
}

function createBoard() {
  board = [];
  boardEl.innerHTML = "";
  for (let r = 0; r < size; r++) {
    board[r] = [];
    for (let c = 0; c < size; c++) {
      const div = document.createElement("div");
      div.classList.add("cell");
      const type = randomTile();
      board[r][c] = type;
      div.style.backgroundImage = `url(img/${type}.png)`;
      div.dataset.row = r;
      div.dataset.col = c;
      boardEl.appendChild(div);
    }
  }
  removeMatches(true);
}

function swap(a, b) {
  const tmp = board[a.r][a.c];
  board[a.r][a.c] = board[b.r][b.c];
  board[b.r][b.c] = tmp;
}

function getMatches() {
  let matched = [];
  // horizontal
  for (let r = 0; r < size; r++) {
    for (let c = 0; c < size - 2; c++) {
      let t = board[r][c];
      if (t && t === board[r][c + 1] && t === board[r][c + 2]) {
        matched.push([r, c], [r, c + 1], [r, c + 2]);
      }
    }
  }
  // vertical
  for (let c = 0; c < size; c++) {
    for (let r = 0; r < size - 2; r++) {
      let t = board[r][c];
      if (t && t === board[r + 1][c] && t === board[r + 2][c]) {
        matched.push([r, c], [r + 1, c], [r + 2, c]);
      }
    }
  }
  return matched;
}

function removeMatches(initial = false) {
  let matches = getMatches();
  if (matches.length === 0) {
    if (!initial && !hasPossibleMoves()) {
      message.textContent = "ðŸŽ® æ²’æœ‰å¯æ¶ˆé™¤çš„çµ„åˆï¼ŒéŠæˆ²çµæŸï¼";
    }
    return;
  }
  for (let [r, c] of matches) {
    board[r][c] = null;
  }
  dropTiles();
  setTimeout(() => {
    fillEmpty();
    render();
    removeMatches();
  }, 300);
}

function dropTiles() {
  for (let c = 0; c < size; c++) {
    for (let r = size - 1; r >= 0; r--) {
      if (board[r][c] === null) {
        for (let rr = r - 1; rr >= 0; rr--) {
          if (board[rr][c] !== null) {
            board[r][c] = board[rr][c];
            board[rr][c] = null;
            break;
          }
        }
      }
    }
  }
}

function fillEmpty() {
  for (let r = 0; r < size; r++) {
    for (let c = 0; c < size; c++) {
      if (board[r][c] === null) {
        board[r][c] = randomTile();
      }
    }
  }
}

function hasPossibleMoves() {
  for (let r = 0; r < size; r++) {
    for (let c = 0; c < size; c++) {
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      for (let [dr, dc] of dirs) {
        const nr = r + dr, nc = c + dc;
        if (nr < 0 || nc < 0 || nr >= size || nc >= size) continue;
        swap({r, c}, {r:nr, c:nc});
        if (getMatches().length > 0) {
          swap({r, c}, {r:nr, c:nc});
          return true;
        }
        swap({r, c}, {r:nr, c:nc});
      }
    }
  }
  return false;
}

function render() {
  const cells = document.querySelectorAll(".cell");
  cells.forEach(cell => {
    const r = +cell.dataset.row;
    const c = +cell.dataset.col;
    const type = board[r][c];
    cell.style.backgroundImage = `url(img/${type}.png)`;
    cell.style.transform = "";
  });
}

function setupDragEvents() {
  const cells = document.querySelectorAll(".cell");
  cells.forEach(cell => {
    cell.addEventListener("mousedown", startDrag);
    cell.addEventListener("touchstart", startDrag);
  });
}

function startDrag(e) {
  if (isSwapping) return;
  e.preventDefault();
  const target = e.target.closest(".cell");
  if (!target) return;
  dragging = target;
  const moveHandler = (ev) => onDragMove(ev, target);
  const endHandler = (ev) => onDragEnd(ev, target, moveHandler, endHandler);

  document.addEventListener("mousemove", moveHandler);
  document.addEventListener("mouseup", endHandler);
  document.addEventListener("touchmove", moveHandler);
  document.addEventListener("touchend", endHandler);
}

function onDragMove(e, cell) {
  const clientX = e.touches ? e.touches[0].clientX : e.clientX;
  const clientY = e.touches ? e.touches[0].clientY : e.clientY;
  cell.style.transform = `translate(${clientX - cell.getBoundingClientRect().left - 32}px, ${clientY - cell.getBoundingClientRect().top - 32}px)`;
}

function onDragEnd(e, cell, moveHandler, endHandler) {
  document.removeEventListener("mousemove", moveHandler);
  document.removeEventListener("mouseup", endHandler);
  document.removeEventListener("touchmove", moveHandler);
  document.removeEventListener("touchend", endHandler);

  const endX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
  const endY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
  const rect = boardEl.getBoundingClientRect();
  const c = Math.floor((endX - rect.left) / 68);
  const r = Math.floor((endY - rect.top) / 68);

  const fromR = +cell.dataset.row;
  const fromC = +cell.dataset.col;

  if (r < 0 || c < 0 || r >= size || c >= size) {
    cell.style.transform = "";
    dragging = null;
    return;
  }

  if (Math.abs(fromR - r) + Math.abs(fromC - c) === 1) {
    isSwapping = true;
    swap({r:fromR, c:fromC}, {r, c});
    render();
    if (getMatches().length > 0) {
      removeMatches();
    } else {
      // ç§»å›žåŽŸä½
      swap({r:fromR, c:fromC}, {r, c});
      setTimeout(render, 200);
    }
    setTimeout(() => isSwapping = false, 300);
  } else {
    cell.style.transform = "";
  }
  dragging = null;
}

createBoard();
setupDragEvents();
</script>
</body>
</html>
