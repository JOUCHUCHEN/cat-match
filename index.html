<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>Ê∂àÊ∂àÊ®ÇÈÅäÊà≤</title>
<style>
  body {
    margin: 0;
    background: #f4f7fa;
    display: flex;
    flex-direction: column;
    align-items: center;
    font-family: "Microsoft JhengHei", sans-serif;
    user-select: none;
    touch-action: none;
  }

  h1 {
    margin: 20px;
    color: #444;
  }

  #board {
    display: grid;
    grid-template-columns: repeat(6, 60px);
    grid-template-rows: repeat(6, 60px);
    gap: 5px;
    position: relative;
  }

  .cell {
    width: 60px;
    height: 60px;
    border-radius: 10px;
    background: #dbeafe;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.25s;
  }

  .cell img {
    width: 56px;
    height: 56px;
    border-radius: 8px;
    pointer-events: none;
    transition: transform 0.25s ease;
  }

  .dragging {
    position: fixed;
    z-index: 999;
    pointer-events: none;
    transform: scale(1.1);
    opacity: 0.9;
  }

  @keyframes fall {
    from { transform: translateY(-70px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
  }

  .fall {
    animation: fall 0.35s ease-out forwards;
  }
</style>
</head>
<body>
  <h1>üåü Ê∂àÊ∂àÊ®ÇÈÅäÊà≤</h1>
  <div id="board"></div>

  <script>
    const rows = 6, cols = 6;
    const board = document.getElementById("board");
    const images = [
      "https://i.imgur.com/8w6gQYQ.png",
      "https://i.imgur.com/fbM7sQ1.png",
      "https://i.imgur.com/nm5y1TG.png",
      "https://i.imgur.com/Wnm4s3Z.png",
      "https://i.imgur.com/vcJb1qf.png",
      "https://i.imgur.com/CcV2czx.png"
    ];
    let grid = [];
    let startRow, startCol;
    let clone = null;
    let offsetX, offsetY;

    function createCell(r, c, imgSrc) {
      const cell = document.createElement("div");
      cell.classList.add("cell");
      cell.dataset.row = r;
      cell.dataset.col = c;
      const img = document.createElement("img");
      img.src = imgSrc;
      cell.appendChild(img);
      board.appendChild(cell);
      return cell;
    }

    function initBoard() {
      board.innerHTML = "";
      grid = [];
      for (let r = 0; r < rows; r++) {
        const row = [];
        for (let c = 0; c < cols; c++) {
          const imgSrc = images[Math.floor(Math.random() * images.length)];
          const cell = createCell(r, c, imgSrc);
          row.push(imgSrc);
          cell.addEventListener("mousedown", dragStart);
          cell.addEventListener("touchstart", dragStart, {passive:false});
        }
        grid.push(row);
      }
    }

    function swapCells(r1, c1, r2, c2) {
      const tmp = grid[r1][c1];
      grid[r1][c1] = grid[r2][c2];
      grid[r2][c2] = tmp;

      const cells = document.querySelectorAll(".cell");
      const cell1 = [...cells].find(c => +c.dataset.row===r1 && +c.dataset.col===c1);
      const cell2 = [...cells].find(c => +c.dataset.row===r2 && +c.dataset.col===c2);
      const img1 = cell1.querySelector("img").src;
      cell1.querySelector("img").src = cell2.querySelector("img").src;
      cell2.querySelector("img").src = img1;
    }

    function checkMatches() {
      const matches = [];
      // Ê©´Âêë
      for (let r = 0; r < rows; r++) {
        let count = 1;
        for (let c = 1; c < cols; c++) {
          if (grid[r][c] === grid[r][c-1]) {
            count++;
          } else {
            if (count >= 3) matches.push({r, c: c-1, len: count, dir: "row"});
            count = 1;
          }
        }
        if (count >= 3) matches.push({r, c: cols-1, len: count, dir: "row"});
      }
      // Áõ¥Âêë
      for (let c = 0; c < cols; c++) {
        let count = 1;
        for (let r = 1; r < rows; r++) {
          if (grid[r][c] === grid[r-1][c]) {
            count++;
          } else {
            if (count >= 3) matches.push({r: r-1, c, len: count, dir: "col"});
            count = 1;
          }
        }
        if (count >= 3) matches.push({r: rows-1, c, len: count, dir: "col"});
      }
      return matches;
    }

    function handleMatches(matches) {
      const cells = document.querySelectorAll(".cell");
      const toRemove = new Set();

      for (const m of matches) {
        if (m.dir === "row") {
          for (let i = 0; i < m.len; i++) toRemove.add(`${m.r},${m.c-i}`);
        } else {
          for (let i = 0; i < m.len; i++) toRemove.add(`${m.r-i},${m.c}`);
        }
      }

      for (const key of toRemove) {
        const [r, c] = key.split(",").map(Number);
        grid[r][c] = null;
        const cell = [...cells].find(cc => +cc.dataset.row===r && +cc.dataset.col===c);
        if (cell) cell.querySelector("img").style.opacity = "0";
      }

      setTimeout(() => applyGravity(), 350);
    }

    function applyGravity() {
      const cells = document.querySelectorAll(".cell");
      for (let c = 0; c < cols; c++) {
        let empty = 0;
        for (let r = rows - 1; r >= 0; r--) {
          if (grid[r][c] === null) {
            empty++;
          } else if (empty > 0) {
            grid[r + empty][c] = grid[r][c];
            grid[r][c] = null;
            const cellFrom = [...cells].find(cc => +cc.dataset.row===r && +cc.dataset.col===c);
            const cellTo = [...cells].find(cc => +cc.dataset.row===r+empty && +cc.dataset.col===c);
            const imgFrom = cellFrom.querySelector("img");
            const imgTo = cellTo.querySelector("img");
            imgTo.src = imgFrom.src;
            imgTo.classList.add("fall");
            imgFrom.style.opacity = "0";
            setTimeout(() => imgTo.classList.remove("fall"), 400);
          }
        }
        for (let r = 0; r < rows; r++) {
          if (grid[r][c] === null) {
            const newImg = images[Math.floor(Math.random() * images.length)];
            grid[r][c] = newImg;
            const cell = [...cells].find(cc => +cc.dataset.row===r && +cc.dataset.col===c);
            const img = cell.querySelector("img");
            img.src = newImg;
            img.classList.add("fall");
            img.style.opacity = "1";
            setTimeout(() => img.classList.remove("fall"), 400);
          }
        }
      }
      const newMatches = checkMatches();
      if (newMatches.length > 0) handleMatches(newMatches);
    }

    // ‚úÖ Êñ∞Áâà dragStartÔºà‰øÆÊ≠£ÈõªËÖ¶ÊîæÂ§ßÂúñÂïèÈ°åÔºâ
    function dragStart(e) {
      e.preventDefault();
      const target = e.target;
      startRow = +target.dataset.row;
      startCol = +target.dataset.col;

      const startX = e.touches ? e.touches[0].clientX : e.clientX;
      const startY = e.touches ? e.touches[0].clientY : e.clientY;
      const rect = target.getBoundingClientRect();
      offsetX = startX - rect.left;
      offsetY = startY - rect.top;

      let moved = false;

      function startClone() {
        if (clone) return;
        clone = target.cloneNode(true);
        clone.classList.add("dragging");
        document.body.appendChild(clone);
        clone.style.left = (startX - offsetX) + "px";
        clone.style.top = (startY - offsetY) + "px";
      }

      function onMove(ev) {
        const x = ev.touches ? ev.touches[0].clientX : ev.clientX;
        const y = ev.touches ? ev.touches[0].clientY : ev.clientY;
        if (!moved && (Math.abs(x - startX) > 5 || Math.abs(y - startY) > 5)) {
          moved = true;
          startClone();
        }
        if (clone) {
          clone.style.left = (x - offsetX) + "px";
          clone.style.top = (y - offsetY) + "px";
        }
      }

      function onEnd(ev) {
        document.removeEventListener("mousemove", onMove);
        document.removeEventListener("mouseup", onEnd);
        document.removeEventListener("touchmove", onMove);
        document.removeEventListener("touchend", onEnd);

        if (!moved) return; // Èªû‰∏Ä‰∏ã‰∏çÊãñÔºå‰∏çÂÅö‰ªª‰Ωï‰∫ã

        const x = ev.changedTouches ? ev.changedTouches[0].clientX : ev.clientX;
        const y = ev.changedTouches ? ev.changedTouches[0].clientY : ev.clientY;
        const dropCell = document.elementFromPoint(x, y);
        if (!dropCell || !dropCell.classList.contains("cell")) {
          animateReturn(clone, startRow, startCol);
          clone = null;
          return;
        }

        const endRow = +dropCell.dataset.row;
        const endCol = +dropCell.dataset.col;
        const dr = Math.abs(endRow - startRow);
        const dc = Math.abs(endCol - startCol);

        if ((dr + dc) === 1) {
          swapCells(startRow, startCol, endRow, endCol);
          const matches = checkMatches();
          if (matches.length > 0) {
            handleMatches(matches);
            clone.remove();
          } else {
            swapCells(startRow, startCol, endRow, endCol);
            animateReturn(clone, startRow, startCol);
          }
        } else {
          animateReturn(clone, startRow, startCol);
        }
      }

      document.addEventListener("mousemove", onMove);
      document.addEventListener("mouseup", onEnd);
      document.addEventListener("touchmove", onMove, {passive:false});
      document.addEventListener("touchend", onEnd);
    }

    function animateReturn(element, row, col) {
      if (!element) return;
      const targetCell = document.querySelector(`.cell[data-row='${row}'][data-col='${col}']`);
      const rect = targetCell.getBoundingClientRect();
      element.style.transition = "all 0.3s ease";
      element.style.left = rect.left + "px";
      element.style.top = rect.top + "px";
      setTimeout(() => element.remove(), 300);
    }

    initBoard();
  </script>
</body>
</html>
