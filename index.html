<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ë≤ìÂí™Ê∂àÊ∂àÊ®Ç</title>
<style>
  body {
    background: linear-gradient(#ffe6cc, #fff);
    font-family: "Comic Sans MS", sans-serif;
    text-align: center;
    user-select: none;
    overflow: hidden;
  }
  h1 {
    margin-top: 20px;
    color: #d65a31;
  }
  #game {
    display: grid;
    grid-template-columns: repeat(6, 70px);
    grid-template-rows: repeat(6, 70px);
    gap: 6px;
    justify-content: center;
    margin: 20px auto;
  }
  .cell {
    width: 70px;
    height: 70px;
    border-radius: 12px;
    background-color: #fff;
    box-shadow: 0 0 6px rgba(0,0,0,0.2);
    transition: transform 0.25s, top 0.25s;
    position: relative;
  }
  .cell img {
    width: 65px;
    height: 65px;
    pointer-events: none;
    transition: transform 0.25s ease;
  }
  .match {
    animation: pop 0.4s ease;
  }
  @keyframes pop {
    0% { transform: scale(1); }
    50% { transform: scale(1.5); }
    100% { transform: scale(0); }
  }
  #score {
    font-size: 20px;
    margin-top: 10px;
    color: #333;
  }
  #gameOver {
    display: none;
    font-size: 28px;
    color: #b00020;
    margin-top: 15px;
  }
</style>
</head>
<body>
  <h1>üêæ Ë≤ìÂí™Ê∂àÊ∂àÊ®Ç üêæ</h1>
  <div id="game"></div>
  <div id="score">ÂàÜÊï∏Ôºö0</div>
  <div id="gameOver">üéÆ ÈÅäÊà≤ÁµêÊùüÔºÅ</div>

  <!-- Èü≥Êïà -->
  <audio id="matchSound" src="match.mp3"></audio>
  <audio id="endSound" src="end.mp3"></audio>

<script>
const gridSize = 6;
const images = ["1.png","2.png","3.png","4.png","5.png","6.png","7.png"];
let grid = [];
let score = 0;
let dragging = null;
let draggingElement = null;
let gameOver = false;
const game = document.getElementById("game");
const scoreDisplay = document.getElementById("score");
const gameOverDisplay = document.getElementById("gameOver");
const matchSound = document.getElementById("matchSound");
const endSound = document.getElementById("endSound");

function createGrid() {
  grid = [];
  game.innerHTML = "";
  for (let i = 0; i < gridSize * gridSize; i++) {
    const cell = document.createElement("div");
    cell.className = "cell";
    const img = document.createElement("img");
    img.src = images[Math.floor(Math.random() * images.length)];
    cell.appendChild(img);
    cell.dataset.index = i;
    addDragTouchEvents(cell);
    game.appendChild(cell);
    grid.push(cell);
  }
  if (!hasAnyMatches()) shuffleGrid();
}

function addDragTouchEvents(cell) {
  cell.addEventListener("mousedown", startDrag);
  cell.addEventListener("touchstart", startDrag);
  cell.addEventListener("mouseup", endDrag);
  cell.addEventListener("touchend", endDrag);
  cell.addEventListener("mousemove", moveDrag);
  cell.addEventListener("touchmove", moveDrag);
}

function startDrag(e) {
  if (gameOver) return;
  e.preventDefault();
  dragging = e.currentTarget;
  dragging.classList.add("dragging");
  draggingElement = dragging.querySelector("img").cloneNode();
  draggingElement.style.position = "fixed";
  draggingElement.style.pointerEvents = "none";
  draggingElement.style.zIndex = "1000";
  draggingElement.style.width = "65px";
  draggingElement.style.height = "65px";
  document.body.appendChild(draggingElement);
  moveDrag(e);
}

function moveDrag(e) {
  if (!draggingElement) return;
  let x, y;
  if (e.touches && e.touches[0]) {
    x = e.touches[0].clientX;
    y = e.touches[0].clientY;
  } else {
    x = e.clientX;
    y = e.clientY;
  }
  draggingElement.style.left = x - 32 + "px";
  draggingElement.style.top = y - 32 + "px";
}

function endDrag(e) {
  if (!dragging) return;
  dragging.classList.remove("dragging");
  if (draggingElement) {
    draggingElement.remove();
    draggingElement = null;
  }

  let target = document.elementFromPoint(
    e.changedTouches ? e.changedTouches[0].clientX : e.clientX,
    e.changedTouches ? e.changedTouches[0].clientY : e.clientY
  );
  if (target && target.classList.contains("cell") && target !== dragging) {
    swapCells(dragging, target);
    if (checkAndRemoveMatches()) {
      setTimeout(() => dropImages(), 500);
    } else {
      // ÁÑ°Ê≥ïÊ∂àÈô§ ‚Üí ÊèõÂõûÂéü‰Ωç
      setTimeout(() => swapCells(dragging, target), 200);
    }
  }
  dragging = null;
}

function swapCells(cellA, cellB) {
  const imgA = cellA.querySelector("img").src;
  const imgB = cellB.querySelector("img").src;
  cellA.querySelector("img").src = imgB;
  cellB.querySelector("img").src = imgA;
}

function checkAndRemoveMatches() {
  let matched = [];

  // Ê©´Âêë
  for (let r = 0; r < gridSize; r++) {
    for (let c = 0; c < gridSize - 2; c++) {
      const i = r * gridSize + c;
      const src1 = grid[i].querySelector("img").src;
      const src2 = grid[i + 1].querySelector("img").src;
      const src3 = grid[i + 2].querySelector("img").src;
      if (src1 === src2 && src2 === src3) {
        matched.push(i, i + 1, i + 2);
      }
    }
  }

  // Áõ¥Âêë
  for (let c = 0; c < gridSize; c++) {
    for (let r = 0; r < gridSize - 2; r++) {
      const i = r * gridSize + c;
      const src1 = grid[i].querySelector("img").src;
      const src2 = grid[i + gridSize].querySelector("img").src;
      const src3 = grid[i + gridSize * 2].querySelector("img").src;
      if (src1 === src2 && src2 === src3) {
        matched.push(i, i + gridSize, i + gridSize * 2);
      }
    }
  }

  matched = [...new Set(matched)];
  if (matched.length === 0) return false;

  matchSound.currentTime = 0;
  matchSound.play();

  score += matched.length * 10;
  scoreDisplay.textContent = "ÂàÜÊï∏Ôºö" + score;

  matched.forEach(i => {
    const img = grid[i].querySelector("img");
    img.classList.add("match");
    setTimeout(() => {
      img.src = "";
      img.classList.remove("match");
    }, 400);
  });
  return true;
}

function dropImages() {
  for (let c = 0; c < gridSize; c++) {
    for (let r = gridSize - 1; r >= 0; r--) {
      const i = r * gridSize + c;
      if (grid[i].querySelector("img").src === "") {
        for (let k = r - 1; k >= 0; k--) {
          const above = grid[k * gridSize + c].querySelector("img");
          if (above.src !== "") {
            grid[i].querySelector("img").src = above.src;
            above.src = "";
            grid[i].style.transform = "translateY(-70px)";
            setTimeout(() => grid[i].style.transform = "translateY(0)", 200);
            break;
          }
        }
        if (grid[i].querySelector("img").src === "") {
          grid[i].querySelector("img").src = images[Math.floor(Math.random() * images.length)];
          grid[i].style.transform = "translateY(-70px)";
          setTimeout(() => grid[i].style.transform = "translateY(0)", 200);
        }
      }
    }
  }
  setTimeout(() => {
    if (checkAndRemoveMatches()) {
      setTimeout(() => dropImages(), 400);
    } else if (!hasAnyMatches()) {
      endGame();
    }
  }, 500);
}

function hasAnyMatches() {
  for (let r = 0; r < gridSize; r++) {
    for (let c = 0; c < gridSize - 2; c++) {
      const i = r * gridSize + c;
      const src1 = grid[i].querySelector("img").src;
      const src2 = grid[i + 1].querySelector("img").src;
      const src3 = grid[i + 2].querySelector("img").src;
      if (src1 === src2 && src2 === src3) return true;
    }
  }
  for (let c = 0; c < gridSize; c++) {
    for (let r = 0; r < gridSize - 2; r++) {
      const i = r * gridSize + c;
      const src1 = grid[i].querySelector("img").src;
      const src2 = grid[i + gridSize].querySelector("img").src;
      const src3 = grid[i + gridSize * 2].querySelector("img").src;
      if (src1 === src2 && src2 === src3) return true;
    }
  }
  return false;
}

function shuffleGrid() {
  for (let i = grid.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    const temp = grid[i].querySelector("img").src;
    grid[i].querySelector("img").src = grid[j].querySelector("img").src;
    grid[j].querySelector("img").src = temp;
  }
  if (!hasAnyMatches()) shuffleGrid();
}

function endGame() {
  gameOver = true;
  gameOverDisplay.style.display = "block";
  endSound.play();
}

createGrid();
</script>
</body>
</html>
