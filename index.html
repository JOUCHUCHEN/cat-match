<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>喵嗚消消樂v1</title>
<style>
  body { text-align: center; font-family: 'Microsoft JhengHei'; background: #fff; }
  #score { font-size: 28px; font-weight: bold; margin: 20px; }
  #board {
    width: 520px; height: 520px;
    margin: auto; display: grid;
    grid-template-columns: repeat(8, 1fr);
    grid-template-rows: repeat(8, 1fr);
    gap: 2px; position: relative;
  }
  .cell {
    width: 62px; height: 62px;
    background-size: cover; background-position: center;
    position: absolute;
    transition: transform 0.5s ease;
  }
</style>
</head>
<body>

<div id="score">喵嗚值：0</div>
<div id="board"></div>

<script>
const rows = 8, cols = 8;
const icons = ['1.png','2.png','3.png','4.png','5.png','6.png','7.png'];
let board = [];
let score = 0;
let cellSize = 65;
const boardDiv = document.getElementById('board');

// 🐾 初始化
function initBoard(){
  do {
    board = [];
    for(let r=0;r<rows;r++){
      let row=[];
      for(let c=0;c<cols;c++){
        row.push(icons[Math.floor(Math.random()*icons.length)]);
      }
      board.push(row);
    }
  } while(checkMatches().length>0);
  renderBoard(true); // 初次建立（會綁事件）
}

// 🖼️ 繪出棋盤
function renderBoard(initial=false){
  if(initial) boardDiv.innerHTML = ''; // ⚠️ 僅首次清空，避免事件丟失

  // 重新更新位置與背景，但不清除現有 cell
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      let cell = document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
      if(!cell){ // 若不存在才新建
        cell = document.createElement('div');
        cell.className = 'cell';
        addDragEvents(cell);
        boardDiv.appendChild(cell);
      }
      cell.style.backgroundImage = `url(${board[r][c]})`;
      cell.dataset.row = r;
      cell.dataset.col = c;
      cell.style.left = (c * cellSize) + 'px';
      cell.style.top = (r * cellSize) + 'px';
    }
  }
}

// 🎯 加上滑動事件
function addDragEvents(cell){
  let startX, startY, startRow, startCol;

  cell.addEventListener('touchstart', e=>{
    const t = e.touches[0];
    startX = t.clientX; startY = t.clientY;
    startRow = parseInt(cell.dataset.row);
    startCol = parseInt(cell.dataset.col);
  });

  cell.addEventListener('mousedown', e=>{
    startX = e.clientX; startY = e.clientY;
    startRow = parseInt(cell.dataset.row);
    startCol = parseInt(cell.dataset.col);
  });

  function endDrag(x,y){
    const dx = x - startX, dy = y - startY;
    let targetRow = startRow, targetCol = startCol;
    if(Math.abs(dx) > Math.abs(dy)){
      if(dx > 20) targetCol++;
      else if(dx < -20) targetCol--;
    } else {
      if(dy > 20) targetRow++;
      else if(dy < -20) targetRow--;
    }
    if(targetRow>=0 && targetRow<rows && targetCol>=0 && targetCol<cols){
      swapCellsAnimated(startRow,startCol,targetRow,targetCol);
    }
  }

  cell.addEventListener('touchend', e=>{
    const t = e.changedTouches[0];
    endDrag(t.clientX, t.clientY);
  });

  cell.addEventListener('mouseup', e=>{
    endDrag(e.clientX, e.clientY);
  });
}

// 🔄 動畫交換
function swapCellsAnimated(r1,c1,r2,c2){
  const cell1 = document.querySelector(`.cell[data-row="${r1}"][data-col="${c1}"]`);
  const cell2 = document.querySelector(`.cell[data-row="${r2}"][data-col="${c2}"]`);
  if(!cell1 || !cell2) return;

  const dx = (c2 - c1) * cellSize;
  const dy = (r2 - r1) * cellSize;

  // 動畫移動
  cell1.style.transform = `translate(${dx}px, ${dy}px)`;
  cell2.style.transform = `translate(${-dx}px, ${-dy}px)`;

  setTimeout(()=>{
    swapCellsSimple(r1,c1,r2,c2);
    const matches = checkMatches();
    if(matches.length>0){
      handleMatches(matches);
    } else {
      // ❗ 無配對則滑回原位
      cell1.style.transform = '';
      cell2.style.transform = '';
    }
  },300);
}

// ✅ 基本交換
function swapCellsSimple(r1,c1,r2,c2){
  [board[r1][c1],board[r2][c2]]=[board[r2][c2],board[r1][c1]];
}

// 🔍 檢查配對
function checkMatches(){
  const matches=[];
  // 橫向
  for(let r=0;r<rows;r++){
    let count=1;
    for(let c=1;c<cols;c++){
      if(board[r][c]===board[r][c-1]) count++;
      else {
        if(count>=3) for(let k=0;k<count;k++) matches.push([r,c-1-k]);
        count=1;
      }
    }
    if(count>=3) for(let k=0;k<count;k++) matches.push([r,cols-1-k]);
  }
  // 直向
  for(let c=0;c<cols;c++){
    let count=1;
    for(let r=1;r<rows;r++){
      if(board[r][c]===board[r-1][c]) count++;
      else {
        if(count>=3) for(let k=0;k<count;k++) matches.push([r-1-k,c]);
        count=1;
      }
    }
    if(count>=3) for(let k=0;k<count;k++) matches.push([rows-1-k,c]);
  }
  return matches;
}

// 💥 處理配對消除
function handleMatches(matches){
  const uniqueMatches = [...new Set(matches.map(JSON.stringify))].map(JSON.parse);
  const groupCount = uniqueMatches.length;
  if(groupCount===0) return;

  let bonusPerTile = 1;
  if(groupCount>=5) bonusPerTile=3;
  else if(groupCount===4) bonusPerTile=2;
  score += bonusPerTile * groupCount;
  document.getElementById('score').innerText = `喵嗚值：${score}`;

  uniqueMatches.forEach(([r,c])=>{
    const cell = document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
    if(cell){
      cell.style.transform = 'scale(1.3)';
      cell.style.transition = 'transform 0.3s ease';
      setTimeout(()=>{
        cell.remove();
        board[r][c] = null;
      },300);
    } else {
      board[r][c] = null;
    }
  });

  setTimeout(()=>{ applyGravity(); },350);
}

// 🪂 下落動畫（上層補入 + 同步滑落）
function applyGravity(){
  const moving = [];
  for(let c=0;c<cols;c++){
    let empty=0;
    for(let r=rows-1;r>=0;r--){
      if(board[r][c]===null){
        empty++;
      }else if(empty>0){
        board[r+empty][c]=board[r][c];
        board[r][c]=null;
        const cell=document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
        if(cell){
          moving.push({cell,dy:empty*cellSize,newRow:r+empty,newCol:c});
        }
      }
    }
    for(let i=0;i<empty;i++){
      const icon=icons[Math.floor(Math.random()*icons.length)];
      board[i][c]=icon;
      const newCell=document.createElement('div');
      newCell.className='cell';
      newCell.style.backgroundImage=`url(${icon})`;
      newCell.dataset.row=i;
      newCell.dataset.col=c;
      newCell.style.left=(c*cellSize)+'px';
      newCell.style.top=(-empty+i)*cellSize+'px';
      addDragEvents(newCell);
      boardDiv.appendChild(newCell);
      moving.push({cell:newCell,dy:(empty)*cellSize,newRow:i,newCol:c});
    }
  }

  moving.forEach(({cell,dy})=>{
    cell.style.transition='transform 0.5s ease';
    cell.style.transform=`translateY(${dy}px)`;
  });

  setTimeout(()=>{
    moving.forEach(({cell,newRow,newCol})=>{
      cell.style.transition='';
      cell.style.transform='';
      cell.style.top=(newRow*cellSize)+'px';
      cell.style.left=(newCol*cellSize)+'px';
      cell.dataset.row=newRow;
      cell.dataset.col=newCol;
    });
    renderBoard(false);
    const matches=checkMatches();
    if(matches.length>0) handleMatches(matches);
  },500);
}

initBoard();
</script>
</body>
</html>

