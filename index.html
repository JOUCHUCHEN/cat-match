<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>喵喵消消樂</title>
<style>
  body {
    background-color: white;
    text-align: center;
    font-family: "微軟正黑體";
    user-select: none;
  }
  h1 {
    font-size: 28px;
    font-weight: bold;
  }
  #game {
    display: grid;
    grid-template-columns: repeat(8, 80px);
    grid-template-rows: repeat(8, 80px);
    gap: 2px;
    justify-content: center;
    margin-top: 10px;
  }
  .cell {
    width: 80px;
    height: 80px;
    position: relative;
  }
  img {
    width: 80px;
    height: 80px;
    position: absolute;
    transition: top 0.25s ease;
  }
  .dragging {
    transform: scale(1.3);
    z-index: 1000;
  }
</style>
</head>
<body>
<h1>喵鳴值：<span id="score">0</span></h1>
<div id="game"></div>

<script>
const rows = 8;
const cols = 8;
const types = 5;
const game = document.getElementById("game");
const scoreDisplay = document.getElementById("score");
let score = 0;

let board = [];
let images = [];

const catImgs = [
  "https://i.imgur.com/E9oQ2BM.png",
  "https://i.imgur.com/SaZ8KzH.png",
  "https://i.imgur.com/fGZKR1C.png",
  "https://i.imgur.com/vyTQy5C.png",
  "https://i.imgur.com/4HkzMPk.png"
];

function randomCat() {
  return Math.floor(Math.random() * types);
}

function createBoard() {
  board = [];
  images = [];
  game.innerHTML = "";
  for (let r = 0; r < rows; r++) {
    const row = [];
    const imgRow = [];
    for (let c = 0; c < cols; c++) {
      const type = randomCat();
      row.push(type);

      const cell = document.createElement("div");
      cell.className = "cell";
      const img = document.createElement("img");
      img.src = catImgs[type];
      img.draggable = false;
      img.dataset.row = r;
      img.dataset.col = c;
      img.dataset.type = type;
      img.style.top = "0px";

      img.addEventListener("mousedown", startDrag);
      img.addEventListener("touchstart", startDrag, { passive: true });

      cell.appendChild(img);
      game.appendChild(cell);
      imgRow.push(img);
    }
    board.push(row);
    images.push(imgRow);
  }
}

let dragItem = null;
let startRow, startCol;
function startDrag(e) {
  e.preventDefault();
  dragItem = e.target;
  startRow = parseInt(dragItem.dataset.row);
  startCol = parseInt(dragItem.dataset.col);
  dragItem.classList.add("dragging");
  document.addEventListener("mouseup", endDrag);
  document.addEventListener("touchend", endDrag);
  document.addEventListener("mousemove", moveDrag);
  document.addEventListener("touchmove", moveDrag, { passive: false });
}

function moveDrag(e) {
  if (!dragItem) return;
  const touch = e.touches ? e.touches[0] : e;
  const target = document.elementFromPoint(touch.clientX, touch.clientY);
  if (target && target.tagName === "IMG" && target !== dragItem) {
    const endRow = parseInt(target.dataset.row);
    const endCol = parseInt(target.dataset.col);
    if (Math.abs(startRow - endRow) + Math.abs(startCol - endCol) === 1) {
      swap(startRow, startCol, endRow, endCol);
      dragItem.classList.remove("dragging");
      dragItem = null;
      removeDragListeners();
    }
  }
}

function endDrag() {
  if (dragItem) dragItem.classList.remove("dragging");
  dragItem = null;
  removeDragListeners();
}

function removeDragListeners() {
  document.removeEventListener("mouseup", endDrag);
  document.removeEventListener("touchend", endDrag);
  document.removeEventListener("mousemove", moveDrag);
  document.removeEventListener("touchmove", moveDrag);
}

function swap(r1, c1, r2, c2) {
  [board[r1][c1], board[r2][c2]] = [board[r2][c2], board[r1][c1]];
  [images[r1][c1].src, images[r2][c2].src] = [images[r2][c2].src, images[r1][c1].src];
  [images[r1][c1].dataset.type, images[r2][c2].dataset.type] = [images[r2][c2].dataset.type, images[r1][c1].dataset.type];
  checkMatches();
}

function checkMatches() {
  let matched = [];
  for (let r = 0; r < rows; r++) {
    matched[r] = [];
    for (let c = 0; c < cols; c++) {
      matched[r][c] = false;
    }
  }

  // 檢查橫向
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols - 2; c++) {
      const type = board[r][c];
      if (type === board[r][c + 1] && type === board[r][c + 2]) {
        matched[r][c] = matched[r][c + 1] = matched[r][c + 2] = true;
      }
    }
  }

  // 檢查縱向
  for (let c = 0; c < cols; c++) {
    for (let r = 0; r < rows - 2; r++) {
      const type = board[r][c];
      if (type === board[r + 1][c] && type === board[r + 2][c]) {
        matched[r][c] = matched[r + 1][c] = matched[r + 2][c] = true;
      }
    }
  }

  let found = false;
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      if (matched[r][c]) {
        found = true;
        board[r][c] = null;
        images[r][c].style.opacity = "0";
      }
    }
  }

  if (found) {
    score += 3;
    scoreDisplay.textContent = score;
    setTimeout(dropCats, 250);
  }
}

function dropCats() {
  for (let c = 0; c < cols; c++) {
    let empty = 0;
    for (let r = rows - 1; r >= 0; r--) {
      if (board[r][c] === null) {
        empty++;
      } else if (empty > 0) {
        board[r + empty][c] = board[r][c];
        images[r + empty][c].src = images[r][c].src;
        images[r + empty][c].dataset.type = images[r][c].dataset.type;
        images[r + empty][c].style.top = `${80 * empty}px`; // ✅ 動畫滑落
        board[r][c] = null;
      }
    }

    // 補新圖（從頂部同步滑下）
    for (let i = 0; i < empty; i++) {
      const newType = randomCat();
      board[i][c] = newType;
      images[i][c].src = catImgs[newType];
      images[i][c].dataset.type = newType;
      images[i][c].style.top = `${-80 * (empty - i)}px`; // ✅ 從上方生成
      setTimeout(() => {
        images[i][c].style.top = "0px";
        images[i][c].style.opacity = "1";
      }, 20);
    }
  }

  setTimeout(() => checkMatches(), 350);
}

createBoard();
</script>
</body>
</html>
