<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>喵嗚消消樂 8x8 自然滑落手機版</title>
<style>
body {
  text-align: center;
  background: #222;
  color: #fff;
  font-family: "微軟正黑體";
  margin: 0;
  overflow-x: hidden;
}

#game {
  display: grid;
  grid-template-columns: repeat(8, 11vw);
  grid-template-rows: repeat(8, 11vw);
  gap: 1vw;
  justify-content: center;
  margin: 4vw auto;
  width: 92vw;
  touch-action: none;
  position: relative;
}

.cell {
  width: 11vw;
  height: 11vw;
  background-size: cover;
  background-position: center;
  border-radius: 2vw;
  cursor: grab;
  position: relative;
  transition: transform 0.35s ease, background-image 0.35s ease;
}

.dragging {
  opacity: 0.8;
  transform: scale(1.2);
  z-index: 1000;
  position: fixed;
  pointer-events: none;
}

.score {
  font-size: 5vw;
  margin-top: 2vw;
}

.plus-text {
  position: fixed;
  font-size: 4vw;
  color: #ffdd00;
  font-weight: bold;
  animation: floatUp 0.8s ease-out forwards;
  pointer-events: none;
}

@keyframes floatUp {
  0% {opacity: 1; transform: translateY(0);}
  100% {opacity: 0; transform: translateY(-6vw);}
}
</style>
</head>
<body>

<h2 style="font-size:6vw;margin-top:3vw;">喵嗚消消樂 8x8</h2>
<div class="score">喵嗚值：<span id="score">0</span></div>
<div id="game"></div>

<script>
const rows = 8, cols = 8;
const icons = ["1.png","2.png","3.png","4.png","5.png","6.png","7.png"];
let board = [];
let score = 0;

const game = document.getElementById("game");
const scoreEl = document.getElementById("score");

// 隨機圖案
function randomIcon() {
  return icons[Math.floor(Math.random() * icons.length)];
}

// 初始化棋盤 (保證無三連)
function initBoard() {
  do {
    board = [];
    for (let r = 0; r < rows; r++) {
      const row = [];
      for (let c = 0; c < cols; c++) {
        row.push(randomIcon());
      }
      board.push(row);
    }
  } while (checkMatches().length > 0);
  renderBoard();
}

// 渲染棋盤
function renderBoard() {
  game.innerHTML = "";
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const cell = document.createElement("div");
      cell.classList.add("cell");
      cell.style.backgroundImage = `url("${board[r][c]}")`;
      cell.dataset.row = r;
      cell.dataset.col = c;
      addDragEvents(cell);
      game.appendChild(cell);
    }
  }
}

// 拖曳變數
let clone = null;
let startRow, startCol;
let offsetX, offsetY;

// 手機與滑鼠通用拖曳
function addDragEvents(cell) {
  cell.addEventListener("mousedown", dragStart);
  cell.addEventListener("touchstart", dragStart, {passive: false});
}

function dragStart(e) {
  e.preventDefault();
  const target = e.target;
  startRow = +target.dataset.row;
  startCol = +target.dataset.col;

  clone = target.cloneNode(true);
  clone.classList.add("dragging");
  document.body.appendChild(clone);

  const rect = target.getBoundingClientRect();
  const x = e.touches ? e.touches[0].clientX : e.clientX;
  const y = e.touches ? e.touches[0].clientY : e.clientY;
  offsetX = x - rect.left;
  offsetY = y - rect.top;
  clone.style.left = (x - offsetX) + "px";
  clone.style.top = (y - offsetY) + "px";

  document.addEventListener("mousemove", dragMove, {passive: false});
  document.addEventListener("mouseup", dragEnd);
  document.addEventListener("touchmove", dragMove, {passive: false});
  document.addEventListener("touchend", dragEnd);
}

function dragMove(e) {
  if (!clone) return;
  const x = e.touches ? e.touches[0].clientX : e.clientX;
  const y = e.touches ? e.touches[0].clientY : e.clientY;
  clone.style.left = (x - offsetX) + "px";
  clone.style.top = (y - offsetY) + "px";
}

function dragEnd(e) {
  if (!clone) return;
  const x = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
  const y = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
  const dropCell = document.elementFromPoint(x, y);
  if (!dropCell || !dropCell.classList.contains("cell")) {
    animateReturn(clone, startRow, startCol);
    clone = null;
    return;
  }
  const endRow = +dropCell.dataset.row;
  const endCol = +dropCell.dataset.col;

  const dr = Math.abs(endRow - startRow);
  const dc = Math.abs(endCol - startCol);

  if ((dr + dc) === 1) {
    swapCells(startRow, startCol, endRow, endCol);
    const matches = checkMatches();
    if (matches.length > 0) {
      handleMatches(matches);
      clone.remove();
    } else {
      swapCells(startRow, startCol, endRow, endCol);
      animateReturn(clone, startRow, startCol);
    }
  } else {
    animateReturn(clone, startRow, startCol);
  }

  document.removeEventListener("mousemove", dragMove);
  document.removeEventListener("mouseup", dragEnd);
  document.removeEventListener("touchmove", dragMove);
  document.removeEventListener("touchend", dragEnd);
}

function animateReturn(cloneEl, r, c) {
  const targetCell = document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
  if (!targetCell) { cloneEl.remove(); return; }
  const rect = targetCell.getBoundingClientRect();
  cloneEl.style.transition = "all 0.35s ease";
  cloneEl.style.left = rect.left + "px";
  cloneEl.style.top = rect.top + "px";
  setTimeout(() => cloneEl.remove(), 360);
}

// 交換格子
function swapCells(r1, c1, r2, c2) {
  [board[r1][c1], board[r2][c2]] = [board[r2][c2], board[r1][c1]];
  renderBoard();
}

// 找出三連以上
function checkMatches() {
  const matches = [];
  for (let r = 0; r < rows; r++) {
    let count = 1;
    for (let c = 1; c < cols; c++) {
      if (board[r][c] === board[r][c-1]) count++;
      else {
        if (count >= 3) for (let k = c - count; k < c; k++) matches.push([r, k]);
        count = 1;
      }
    }
    if (count >= 3) for (let k = cols - count; k < cols; k++) matches.push([r, k]);
  }
  for (let c = 0; c < cols; c++) {
    let count = 1;
    for (let r = 1; r < rows; r++) {
      if (board[r][c] === board[r-1][c]) count++;
      else {
        if (count >= 3) for (let k = r - count; k < r; k++) matches.push([k, c]);
        count = 1;
      }
    }
    if (count >= 3) for (let k = rows - count; k < rows; k++) matches.push([k, c]);
  }
  return matches;
}

// 消除
function clearMatches(matches) {
  const cleared = new Set();
  matches.forEach(([r, c]) => {
    const key = r + "-" + c;
    if (!cleared.has(key)) {
      board[r][c] = null;
      showPlusEffect(r, c);
      cleared.add(key);
    }
  });
  score += cleared.size;
  scoreEl.textContent = score;
}

// 下落
function applyGravity() {
  for (let c = 0; c < cols; c++) {
    for (let r = rows - 1; r >= 0; r--) {
      if (board[r][c] === null) {
        let upper = r - 1;
        while (upper >= 0 && board[upper][c] === null) upper--;
        if (upper >= 0) {
          board[r][c] = board[upper][c];
          board[upper][c] = null;
        }
      }
    }
  }
  renderBoard();
}

// 補圖
function refillBoard() {
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      if (board[r][c] === null) {
        board[r][c] = randomIcon();
      }
    }
  }
  renderBoard();
}

// 消除流程
function handleMatches(matches) {
  clearMatches(matches);
  setTimeout(() => {
    applyGravity();
    setTimeout(() => {
      refillBoard();
      const newMatches = checkMatches();
      if (newMatches.length > 0) handleMatches(newMatches);
      else if (!hasPossibleMoves()) gameOver();
    }, 350);
  }, 350);
}

// +1 動畫
function showPlusEffect(r, c) {
  const cell = document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
  if (!cell) return;
  const rect = cell.getBoundingClientRect();
  const plus = document.createElement("div");
  plus.classList.add("plus-text");
  plus.textContent = "+1";
  plus.style.left = rect.left + "px";
  plus.style.top = rect.top + "px";
  document.body.appendChild(plus);
  setTimeout(() => plus.remove(), 800);
}

// 可移動判斷
function hasPossibleMoves() {
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      if (r < rows - 1) {
        swapSimple(r, c, r + 1, c);
        if (checkMatches().length > 0) { swapSimple(r, c, r + 1, c); return true; }
        swapSimple(r, c, r + 1, c);
      }
      if (c < cols - 1) {
        swapSimple(r, c, r, c + 1);
        if (checkMatches().length > 0) { swapSimple(r, c, r, c + 1); return true; }
        swapSimple(r, c, r, c + 1);
      }
    }
  }
  return false;
}

function swapSimple(r1, c1, r2, c2) {
  [board[r1][c1], board[r2][c2]] = [board[r2][c2], board[r1][c1]];
}

function gameOver() {
  alert("喵嗚值：" + score + "，遊戲結束！");
}

initBoard();
</script>

</body>
</html>
