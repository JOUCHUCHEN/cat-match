<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>喵嗚值消消樂（修正下落）</title>
<style>
  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
    background: #f8f8f8;
    margin: 0;
    user-select: none;
    touch-action: none;
  }
  #board {
    display: grid;
    grid-template-columns: repeat(8, 65px);
    grid-template-rows: repeat(8, 65px);
    gap: 4px;
  }
  .cell {
    width: 65px;
    height: 65px;
    background-size: cover;
    border-radius: 10px;
    transition: transform 0.5s ease, background-image 0.3s ease;
  }
  #score {
    font-size: 24px;
    font-weight: bold;
    margin-bottom: 10px;
  }
</style>
</head>
<body>

<div id="score">喵嗚值：0</div>
<div id="board"></div>

<script>
const rows = 8, cols = 8;
const icons = [
  "1.png","2.png","3.png","4.png","5.png","6.png","7.png"
];
let board = [];
let score = 0;
let dragging = false;
let startCell = null;
const scoreEl = document.getElementById("score");

function randomIcon(){
  return icons[Math.floor(Math.random()*icons.length)];
}

function initBoard(){
  board = [];
  for(let r=0;r<rows;r++){
    board[r] = [];
    for(let c=0;c<cols;c++){
      let icon;
      do{
        icon = randomIcon();
        board[r][c] = icon;
      }while(checkInitialMatch(r,c));
    }
  }
  renderBoard();
}

function checkInitialMatch(r,c){
  if(c>=2 && board[r][c]===board[r][c-1] && board[r][c]===board[r][c-2]) return true;
  if(r>=2 && board[r][c]===board[r-1][c] && board[r][c]===board[r-2][c]) return true;
  return false;
}

function renderBoard(){
  const boardDiv = document.getElementById("board");
  boardDiv.innerHTML = "";
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const cell = document.createElement("div");
      cell.className = "cell";
      cell.dataset.row = r;
      cell.dataset.col = c;
      if(board[r][c]) cell.style.backgroundImage = `url(${board[r][c]})`;
      else cell.style.backgroundImage = "none";
      addEvent(cell);
      boardDiv.appendChild(cell);
    }
  }
}

function addEvent(cell){
  cell.addEventListener("mousedown",startDrag);
  cell.addEventListener("touchstart",startDrag);
  cell.addEventListener("mouseup",endDrag);
  cell.addEventListener("touchend",endDrag);
}

function startDrag(e){
  e.preventDefault();
  dragging = true;
  startCell = e.target;
}

function endDrag(e){
  if(!dragging) return;
  dragging = false;
  const endCell = document.elementFromPoint(
    e.changedTouches ? e.changedTouches[0].clientX : e.clientX,
    e.changedTouches ? e.changedTouches[0].clientY : e.clientY
  );
  if(!endCell || !endCell.classList.contains("cell")) return;

  const r1 = +startCell.dataset.row;
  const c1 = +startCell.dataset.col;
  const r2 = +endCell.dataset.row;
  const c2 = +endCell.dataset.col;

  if(Math.abs(r1-r2)+Math.abs(c1-c2)===1){
    swapCellsAnimated(r1,c1,r2,c2);
  }
}

function swapCellsAnimated(r1,c1,r2,c2){
  const cell1 = document.querySelector(`.cell[data-row="${r1}"][data-col="${c1}"]`);
  const cell2 = document.querySelector(`.cell[data-row="${r2}"][data-col="${c2}"]`);
  const temp = board[r1][c1];
  board[r1][c1] = board[r2][c2];
  board[r2][c2] = temp;

  cell1.style.transition = "transform 0.3s";
  cell2.style.transition = "transform 0.3s";
  const dx = (c2-c1)*69;
  const dy = (r2-r1)*69;
  cell1.style.transform = `translate(${dx}px,${dy}px)`;
  cell2.style.transform = `translate(${-dx}px,${-dy}px)`;

  setTimeout(()=>{
    cell1.style.transition = "";
    cell2.style.transition = "";
    cell1.style.transform = "";
    cell2.style.transform = "";
    renderBoard();
    handleMatches();
  },300);
}

function handleMatches(){
  const matches = checkMatches();
  if(matches.length>0){
    clearMatches(matches);
    setTimeout(()=>{
      applyGravity();
    },300);
  }else if(!hasPossibleMove()){
    gameOver();
  }
}

function checkMatches(){
  const matches = [];
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const icon = board[r][c];
      if(!icon) continue;
      if(c<cols-2 && board[r][c+1]===icon && board[r][c+2]===icon){
        let len=3;
        while(c+len<cols && board[r][c+len]===icon) len++;
        for(let k=0;k<len;k++) matches.push([r,c+k]);
      }
      if(r<rows-2 && board[r+1][c]===icon && board[r+2][c]===icon){
        let len=3;
        while(r+len<rows && board[r+len][c]===icon) len++;
        for(let k=0;k<len;k++) matches.push([r+k,c]);
      }
    }
  }
  return matches;
}

function clearMatches(matches){
  const cleared = {};
  matches.forEach(([r,c])=>{
    const key = r+'-'+c;
    if(!cleared[key]) cleared[key] = true;
  });
  const countMap = {};
  for(const key in cleared){
    const [r,c] = key.split('-').map(Number);
    const icon = board[r][c];
    countMap[icon] = (countMap[icon]||0)+1;
  }
  let addScore = 0;
  for(const icon in countMap){
    const n = countMap[icon];
    if(n===3) addScore += 1*3;
    else if(n===4) addScore += 2*4;
    else if(n>=5) addScore += 3*n;
  }
  score += addScore;
  scoreEl.textContent = "喵嗚值：" + score;

  matches.forEach(([r,c])=>{
    board[r][c] = null;
    const cell = document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
    if(cell) cell.style.backgroundImage = "none";
  });
}

// ===== 修正版 applyGravity()：確保所有應下落的舊格 + 新補格 同步滑落，且不會影響下方不該移動的格子 =====
function applyGravity(){
  let moved = false;
  const boardDiv = document.getElementById("board");
  const cellPrototype = document.querySelector('.cell');
  const cellH = cellPrototype ? cellPrototype.offsetHeight : 65; // fallback
  const gap = 4; // grid gap in px (as per CSS)
  const cellsToAnimate = []; // {element, startTop, endTop}

  // 1) 計算每一列空格數與要下移的來源格，先更新 board（但不改 DOM）
  for(let c=0;c<cols;c++){
    let emptySpots = 0;
    for(let r=rows-1;r>=0;r--){
      if(board[r][c]===null){
        emptySpots++;
      } else if(emptySpots>0){
        // 移動邏輯：值搬到下面
        board[r+emptySpots][c] = board[r][c];
        board[r][c] = null;
        moved = true;
      }
    }
    // 最上方空位數量 emptySpots 表示需要補入的數量
    // 將新圖填入 board 的最上方位置（board[0..emptySpots-1][c]）
    for(let i=0;i<emptySpots;i++){
      board[i][c] = randomIcon();
    }
  }

  // 2) 建立動畫：對「畫面上現有的 DOM cell」計算從哪裡到哪裡（使用當前 DOM 布局）
  // 我們先 snapshot 現有 DOM cell rects（在 renderBoard 之後存在）
  const domCells = Array.from(document.querySelectorAll('.cell'));
  // build map by row/col -> element & rect
  const rectMap = {};
  domCells.forEach(el=>{
    const r = +el.dataset.row;
    const c = +el.dataset.col;
    rectMap[`${r}-${c}`] = el.getBoundingClientRect();
  });

  // For each original DOM cell that had a non-null value BEFORE gravity, find its new row
  // But we already modified board; we need to determine for each original position (r,c) where its value moved.
  // We'll iterate original positions from top to bottom and compute how many empty spots below it existed originally.
  // To get original empties we can recompute from a copy of board BEFORE we modified it.
  // So produce a snapshot of boardBefore from DOM backgroundImages.

  // Build boardBefore by reading current DOM background images (safe because renderBoard created them)
  const boardBefore = [];
  for(let r=0;r<rows;r++){
    boardBefore[r] = [];
    for(let c=0;c<cols;c++){
      const el = document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
      const bg = el ? el.style.backgroundImage : "";
      // extract filename from url("...") or leave null if none
      if(bg && bg !== "none") {
        // bg is like url("1.png") or url(1.png)
        const m = bg.match(/url\(["']?(.*?)["']?\)/);
        boardBefore[r][c] = m ? m[1] : bg;
      } else {
        boardBefore[r][c] = null;
      }
    }
  }

  // Now calculate movements for original cells that existed (boardBefore has their icons)
  for(let c=0;c<cols;c++){
    let emptyBelow = 0;
    for(let r=rows-1;r>=0;r--){
      if(boardBefore[r][c]===null){
        emptyBelow++;
      } else {
        if(emptyBelow>0){
          const sourceEl = document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
          const targetRow = r + emptyBelow;
          const targetEl = document.querySelector(`.cell[data-row="${targetRow}"][data-col="${c}"]`);
          if(sourceEl && targetEl){
            const srcRect = sourceEl.getBoundingClientRect();
            const tgtRect = targetEl.getBoundingClientRect();
            // compute translate distance
            const dy = tgtRect.top - srcRect.top;
            cellsToAnimate.push({el: sourceEl, dy});
          }
        }
      }
    }
  }

  // 3) 新補的格子：建立 fixed clone 元素在畫面上方並動畫到目標位置（不影響 grid flow）
  const clones = [];
  for(let c=0;c<cols;c++){
    // Count how many empty slots were originally in this column (boardBefore)
    let emptySpots = 0;
    for(let r=rows-1;r>=0;r--){
      if(boardBefore[r][c]===null) emptySpots++;
    }
    if(emptySpots<=0) continue;
    // For i from 0..emptySpots-1 (topmost new positions), target is row i
    for(let i=0;i<emptySpots;i++){
      const targetRow = i;
      const targetEl = document.querySelector(`.cell[data-row="${targetRow}"][data-col="${c}"]`);
      if(!targetEl) continue;
      const tgtRect = targetEl.getBoundingClientRect();
      // start position: above by emptySpots * (cellH + gap)
      const startTop = tgtRect.top - (emptySpots * (cellH + gap));
      const left = tgtRect.left;
      const clone = document.createElement('div');
      clone.className = 'cell';
      clone.style.position = 'fixed';
      clone.style.left = left + 'px';
      clone.style.top = startTop + 'px';
      clone.style.width = tgtRect.width + 'px';
      clone.style.height = tgtRect.height + 'px';
      clone.style.backgroundImage = `url(${board[targetRow][c]})`;
      clone.style.zIndex = 999;
      clone.style.transition = "transform 0.5s ease";
      // set initial transform to 0, but we'll animate by translate to (tgtRect.top - startTop)
      const dy = (tgtRect.top - startTop);
      document.body.appendChild(clone);
      // use translate for animation
      clone.style.transform = `translateY(${dy}px)`;
      clones.push(clone);
    }
  }

  // 4) animate original cells (use translate based on dy)
  cellsToAnimate.forEach(item=>{
    item.el.style.transition = "transform 0.5s ease";
    item.el.style.transform = `translateY(${item.dy}px)`;
  });

  // 5) after animation, cleanup clones and reset transforms, then renderBoard()
  setTimeout(()=>{
    clones.forEach(cl=>{
      cl.remove();
    });
    cellsToAnimate.forEach(item=>{
      item.el.style.transition = "";
      item.el.style.transform = "";
    });
    renderBoard();
    // after re-render, continue the chain (check new matches)
    const newMatches = checkMatches();
    if(newMatches.length>0){
      // small delay to show new matches being cleared
      setTimeout(()=>{ clearMatches(newMatches); setTimeout(()=>applyGravity(),300); },100);
    } else if(!hasPossibleMove()){
      gameOver();
    }
  }, 500);

  return moved;
}
// ===== end applyGravity() 修正版 =====

function hasPossibleMove(){
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      if(r<rows-1){
        swapSimple(r,c,r+1,c);
        if(checkMatches().length>0){swapSimple(r,c,r+1,c);return true;}
        swapSimple(r,c,r+1,c);
      }
      if(c<cols-1){
        swapSimple(r,c,r,c+1);
        if(checkMatches().length>0){swapSimple(r,c,r,c+1);return true;}
        swapSimple(r,c,r,c+1);
      }
    }
  }
  return false;
}

function swapSimple(r1,c1,r2,c2){
  [board[r1][c1],board[r2][c2]]=[board[r2][c2],board[r1][c1]];
}

function gameOver(){
  alert("遊戲結束！最終喵嗚值：" + score);
}

// start
initBoard();
</script>

</body>
</html>
